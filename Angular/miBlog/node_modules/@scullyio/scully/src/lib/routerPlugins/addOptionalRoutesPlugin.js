"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addOptionalRoutes = void 0;
const pluginRepository_1 = require("../pluginManagement/pluginRepository");
const config_1 = require("../utils/config");
const interfacesandenums_1 = require("../utils/interfacesandenums");
const log_1 = require("../utils/log");
exports.addOptionalRoutes = async (routeList = []) => {
    const routesToGenerate = await routeList.reduce(async (result, cur) => {
        const x = await result;
        const config = config_1.scullyConfig.routes[cur];
        if (config) {
            const postRenderers = Array.isArray(config.postRenderers)
                ? config.postRenderers
                : undefined;
            const renderPlugin = config['renderPlugin'];
            /** adding in the postrenderes. Note that the plugin might choose to overwrite the ones that come from the config */
            const r = (await routePluginHandler(cur)).map((row) => ({ renderPlugin, postRenderers, ...row, config }));
            x.push(...r);
        }
        else if (cur.includes('/:')) {
            log_1.logWarn(`No configuration for route "${log_1.yellow(cur)}" found. Skipping`);
        }
        else {
            x.push({ route: cur, type: interfacesandenums_1.RouteTypes.default });
        }
        return x;
    }, Promise.resolve([]));
    return routesToGenerate;
};
async function routePluginHandler(route) {
    const config = config_1.scullyConfig.routes;
    const conf = config[route];
    if (!conf) {
        log_1.logError(`No configuration for route "${log_1.yellow(route)}" found. Skipping`);
        return [{ route, type: interfacesandenums_1.RouteTypes.default }];
    }
    if (pluginRepository_1.plugins.router[conf.type]) {
        const generatedRoutes = (await pluginRepository_1.plugins.router[conf.type](route, conf));
        generatedRoutes.forEach((handledRoute) => {
            if (!handledRoute.route.startsWith('/')) {
                log_1.logWarn(`The plugin '${conf.type}' needs to return handledRoutes with a route that starts with '/'. The route ${JSON.stringify(handledRoute)} is invalid.`);
            }
            if (handledRoute.route.includes('?')) {
                const updatedRoute = handledRoute.route.split('?')[0];
                log_1.logWarn(`The route "${log_1.yellow(handledRoute.route)}" contains a search param, this will be ignored during rendering. it will be truncated to:
  "${log_1.yellow(updatedRoute)}"`);
                handledRoute.route = updatedRoute;
            }
            if (handledRoute.route.includes('#')) {
                const updatedRoute = handledRoute.route.split('#')[0];
                log_1.logWarn(`The route "${log_1.yellow(handledRoute.route)}" contains a hash(#), this will be ignored during rendering. it will be truncated to:
            "${log_1.yellow(updatedRoute)}"`);
                handledRoute.route = updatedRoute;
            }
        });
        return generatedRoutes;
    }
    return [{ route, type: interfacesandenums_1.RouteTypes.default }];
}
//# sourceMappingURL=addOptionalRoutesPlugin.js.map