"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addExtraRoutes = exports.traverseAppRoutes = void 0;
const fs_1 = require("fs");
const guess_parser_1 = require("guess-parser");
const path_1 = require("path");
const cli_options_1 = require("../utils/cli-options");
const config_1 = require("../utils/config");
const fsFolder_1 = require("../utils/fsFolder");
const log_1 = require("../utils/log");
const createFolderFor_1 = require("../utils/createFolderFor");
const pluginRepository_1 = require("../pluginManagement/pluginRepository");
exports.traverseAppRoutes = Symbol('traverseAppRoutes');
const plugin = async (forceScan = cli_options_1.scanRoutes) => {
    const appRootFolder = config_1.scullyConfig.projectRoot;
    const routesPath = path_1.join(config_1.scullyConfig.homeFolder, 'node_modules/.cache/@scullyio', `${config_1.scullyConfig.projectName}.unhandledRoutes.json`);
    const extraRoutes = await addExtraRoutes();
    let routes = [];
    if (!config_1.scullyConfig.bareProject) {
        /** read from cache when exists and not forced to scan. */
        if (forceScan === false && fsFolder_1.existFolder(routesPath)) {
            try {
                const result = JSON.parse(fs_1.readFileSync(routesPath).toString());
                log_1.logWarn(`
----------------------------------
Using stored unhandled routes!.
   To discover new routes in the angular app use "${log_1.yellow('npm run scully -- --scanRoutes')}"
----------------------------------`);
                /** return de-duplicated set of routes */
                return [...new Set([...result, ...extraRoutes]).values()];
            }
            catch (_a) { }
        }
        log_1.log('traversing app for routes');
        log_1.printProgress(undefined, 'Loading guess-parser');
        const excludedFiles = config_1.scullyConfig.guessParserOptions && config_1.scullyConfig.guessParserOptions.excludedFiles
            ? config_1.scullyConfig.guessParserOptions.excludedFiles
            : [];
        try {
            let file = path_1.join(appRootFolder, 'tsconfig.app.json');
            if (!fsFolder_1.existFolder(file)) {
                file = path_1.join(appRootFolder, '../tsconfig.app.json');
            }
            if (!fsFolder_1.existFolder(file)) {
                file = path_1.join(appRootFolder, '../../tsconfig.app.json');
            }
            if (!fsFolder_1.existFolder(file)) {
                log_1.logWarn(`We could not find "${log_1.yellow(file)}". Using the apps source folder as source. This might lead to unpredictable results`);
                routes = guess_parser_1.parseAngularRoutes(appRootFolder, excludedFiles).map((r) => r.path);
            }
            else {
                routes = guess_parser_1.parseAngularRoutes(file, excludedFiles).map((r) => r.path);
            }
        }
        catch (e) {
            if (cli_options_1.sge) {
                console.error(e);
            }
            log_1.logError(`
We encountered a problem while reading the routes from your applications source.
This might happen when there are lazy-loaded routes, that are not loaded,
Or when there are paths we can not resolve statically.
Check the routes in your app, rebuild and retry.
${log_1.yellow('(You can inspect the error by passing the --showGuessError flag')}

${log_1.green('When there are extraRoutes in your config, we will still try to render those.')}

`);
        }
        // process.exit(15);
        if (routes.findIndex((r) => r.trim() === '' || r.trim() === '/') === -1) {
            /** make sure the root Route is always rendered. */
            routes.push('/');
        }
        /** cache the scanned routes */
        createFolderFor_1.createFolderFor(routesPath);
        fs_1.writeFileSync(routesPath, JSON.stringify(routes));
    }
    /** de-duplicate routes */
    return [...new Set([...routes, ...extraRoutes]).values()];
};
async function addExtraRoutes() {
    const isPromise = (x) => x && x.then !== undefined && typeof x.then === 'function';
    const extraRoutes = config_1.scullyConfig.extraRoutes;
    if (!extraRoutes) {
        return [];
    }
    if (typeof extraRoutes === 'string') {
        /** convert a simple string to an array */
        return [extraRoutes];
    }
    const workList = [];
    if (isPromise(extraRoutes)) {
        const outerResult = await extraRoutes;
        if (typeof outerResult === 'string') {
            /** ok, we got a promise<string> return the result */
            return [outerResult];
        }
        workList.push(...outerResult);
    }
    else if (Array.isArray(extraRoutes)) {
        extraRoutes.forEach((r) => {
            if (workList.includes(r)) {
                /** don't add duplicates */
                return;
            }
            workList.push(r);
        });
    }
    else {
        log_1.logWarn(`ExtraRoutes must be provided as an string array. Current type: ${typeof extraRoutes}`);
        return [];
    }
    const result = [];
    for (const route of workList) {
        /** note, this ignores non-string/non-promise things in array */
        if (typeof route === 'string') {
            result.push(route);
        }
        if (isPromise(route)) {
            const x = await route;
            if (typeof x === 'string') {
                result.push(x);
            }
            if (Array.isArray(x)) {
                x.forEach((s) => {
                    if (typeof s === 'string') {
                        result.push(s);
                    }
                });
            }
        }
    }
    return result;
}
exports.addExtraRoutes = addExtraRoutes;
pluginRepository_1.registerPlugin(pluginRepository_1.scullySystem, exports.traverseAppRoutes, plugin);
//# sourceMappingURL=traverseAppRoutesPlugin.js.map