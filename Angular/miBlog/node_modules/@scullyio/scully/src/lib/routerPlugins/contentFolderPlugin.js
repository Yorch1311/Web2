"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.slugify = exports.contentFolderPlugin = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const pluginRepository_1 = require("../pluginManagement/pluginRepository");
const readFileAndCheckPrePublishSlug_1 = require("../renderPlugins/content-render-utils/readFileAndCheckPrePublishSlug");
const captureMessage_1 = require("../utils/captureMessage");
const config_1 = require("../utils/config");
const log_1 = require("../utils/log");
let basePath;
async function contentFolderPlugin(angularRoute, conf) {
    const parts = angularRoute.split('/');
    /** for now, just handle the First parameter. Not sure if/how we can handle multiple ones. */
    const param = parts.filter((p) => p.startsWith(':')).map((id) => id.slice(1))[0];
    const paramConfig = conf[param];
    if (!paramConfig) {
        console.error(`missing config for parameters (${param}) in route: ${angularRoute}. Skipping`);
        return [];
    }
    const baseRoute = angularRoute.split(':' + param)[0];
    basePath = path_1.join(config_1.scullyConfig.homeFolder, paramConfig.folder);
    log_1.log(`Finding files in folder "${log_1.yellow(basePath)}"`);
    const handledRoutes = await checkSourceIsDirectoryAndRun(basePath, baseRoute, conf);
    log_1.printProgress(handledRoutes.length, 'content files added');
    return handledRoutes;
}
exports.contentFolderPlugin = contentFolderPlugin;
async function checkSourceIsDirectoryAndRun(path, baseRoute, conf) {
    const files = await new Promise((resolve) => fs_1.readdir(path, (err, data) => {
        if (err) {
            captureMessage_1.captureException(err);
        }
        return resolve(data);
    }));
    const handledRoutes = [];
    for (const sourceFile of files) {
        const ext = path_1.extname(sourceFile);
        // const ext = sourceFile.split('.').pop();
        const templateFile = path_1.join(path, sourceFile);
        if (fs_1.lstatSync(templateFile).isDirectory()) {
            handledRoutes.push(...(await checkSourceIsDirectoryAndRun(templateFile, baseRoute, conf)));
        }
        else {
            if (checkIfEmpty(templateFile)) {
                log_1.logWarn(`The file ${log_1.yellow(templateFile)} is empty, scully will ignore.`);
            }
            else if (!hasContentPlugin(ext)) {
                log_1.logWarn(`The file ${log_1.yellow(templateFile)} has extension ${log_1.yellow(ext)} that has no plugin defined, scully will skip this file.`);
            }
            else {
                handledRoutes.push(...(await addHandleRoutes(sourceFile, baseRoute, templateFile, conf, ext)));
                // await new Promise((r) => setTimeout(() => r(), 2000));
                log_1.printProgress(handledRoutes.length, 'content files added');
            }
        }
    }
    return handledRoutes;
}
function hasContentPlugin(extension) {
    const availAblePlugins = pluginRepository_1.plugins.fileHandler;
    extension = extension.toLowerCase().trim();
    extension = extension.startsWith('.') ? extension.slice(1) : extension;
    return (Object.entries(availAblePlugins).find(([name, plugin]) => extension === name.toLowerCase() ||
        (Array.isArray(plugin[pluginRepository_1.AlternateExtensionsForFilePlugin]) && plugin[pluginRepository_1.AlternateExtensionsForFilePlugin].includes(extension))) !== undefined);
}
function checkIfEmpty(templateFile) {
    try {
        const file = fs_1.readFileSync(templateFile).toString();
        return file.length === 0 ? true : false;
    }
    catch (e) {
        return false;
    }
}
async function addHandleRoutes(sourceFile, baseRoute, templateFile, conf, ext) {
    const handledRoutes = [];
    const base = path_1.basename(sourceFile, ext);
    // if a subfolder we need add a route for this folder
    let routify = (frag) => `${baseRoute}${slugify(frag)}`;
    // replace \ for / for windows
    const newTemplateFile = templateFile.split('\\').join('/');
    if (!newTemplateFile.endsWith(`${basePath}/${sourceFile}`)) {
        /** get the 'path' part of as a route partial */
        const routePartial = newTemplateFile.substr(basePath.length + 1).replace(sourceFile, '');
        routify = (frag) => `${baseRoute}${routePartial}${slugify(frag)}`;
    }
    const { meta, prePublished } = await readFileAndCheckPrePublishSlug_1.readFileAndCheckPrePublishSlug(templateFile);
    const name = conf.name;
    const handledRoute = {
        route: routify(meta.slug || base),
        type: conf.type,
        templateFile,
        data: { name, ...meta, sourceFile },
    };
    handledRoutes.push(handledRoute);
    if (!prePublished && Array.isArray(meta.slugs)) {
        /** also add routes for all available slugs */
        meta.slugs
            .filter((slug) => typeof slug === 'string')
            .map(routify)
            .forEach((route) => handledRoutes.push({ ...handledRoute, route }));
    }
    return handledRoutes;
}
function slugify(frag) {
    return frag.trim().split('/').join('_').split(' ').join('_').split('?').join('_');
}
exports.slugify = slugify;
// TODO actual validation of the config
const configValidator = async (conf) => {
    // return [yellow('all seems ok')];
    return [];
};
pluginRepository_1.registerPlugin('router', 'contentFolder', contentFolderPlugin, configValidator);
//# sourceMappingURL=contentFolderPlugin.js.map