"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createScript = exports.reloadAll = exports.isBuildThere = exports.restartStaticServer = exports.startScullyWatchMode = exports.checkForManualRestart = exports.watchMode = exports.bootServe = void 0;
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
// server.js
const ws_1 = require("ws");
const __1 = require("../");
const cli_options_1 = require("./utils/cli-options");
const config_1 = require("./utils/config");
const fsAngular_1 = require("./utils/fsAngular");
const fsFolder_1 = require("./utils/fsFolder");
const httpGetJson_1 = require("./utils/httpGetJson");
const log_1 = require("./utils/log");
const captureMessage_1 = require("./utils/captureMessage");
const staticServer_1 = require("./utils/serverstuff/staticServer");
async function bootServe(scullyConfig) {
    const port = cli_options_1.path || scullyConfig.staticPort;
    console.log('starting static server');
    process.title = 'ScullyServer';
    startStaticServer();
}
exports.bootServe = bootServe;
// TODO : we need rewrite this to observables for don't have memory leaks
// tslint:disable-next-line:variable-name
async function watchMode(path) {
    await fsFolder_1.checkStaticFolder();
    // g for generate and the q for quit
    checkForManualRestart();
    // @ts-ignore
    await fsAngular_1.checkChangeAngular(path, false, true);
}
exports.watchMode = watchMode;
function checkForManualRestart() {
    const readline = require('readline').createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    // @ts-ignore
    readline.addListener('close', async () => {
        log_1.log(`${log_1.yellow('------------------------------------------------------------')}`);
        log_1.log(`Killing Scully by ${log_1.green('ctrl+c')}.`);
        log_1.log(`${log_1.yellow('------------------------------------------------------------')}`);
        await httpGetJson_1.httpGetJson(`http://${__1.scullyConfig.hostName}:${__1.scullyConfig.appPort}/killMe`, {
            suppressErrors: true,
        }).catch((e) => {
            captureMessage_1.captureException(e);
            return e;
        });
        await httpGetJson_1.httpGetJson(`https://${__1.scullyConfig.hostName}:${__1.scullyConfig.appPort}/killMe`, {
            suppressErrors: true,
        }).catch((e) => {
            captureMessage_1.captureException(e);
            return e;
        });
        process.exit(0);
    });
    readline.question(``, async (command) => {
        if (command.toLowerCase() === 'r') {
            __1.startScully().then(() => {
                readline.close();
                checkForManualRestart();
            });
        }
        else if (command.toLowerCase() === 'q') {
            await httpGetJson_1.httpGetJson(`http://${__1.scullyConfig.hostName}:${__1.scullyConfig.appPort}/killMe`, {
                suppressErrors: true,
            }).catch((e) => {
                captureMessage_1.captureException(e);
                return e;
            });
            await httpGetJson_1.httpGetJson(`https://${__1.scullyConfig.hostName}:${__1.scullyConfig.appPort}/killMe`, {
                suppressErrors: true,
            }).catch((e) => {
                captureMessage_1.captureException(e);
                return e;
            });
            process.exit(0);
            return;
        }
        else {
            log_1.log(`${log_1.yellow('------------------------------------------------------------')}`);
            log_1.log(`Press ${log_1.green('r')} for re-run Scully, or ${log_1.green('q')} for close the servers.`);
            log_1.log(`${log_1.yellow('------------------------------------------------------------')}`);
        }
    });
}
exports.checkForManualRestart = checkForManualRestart;
function startScullyWatchMode(url) {
    __1.startScully(url);
}
exports.startScullyWatchMode = startScullyWatchMode;
function startStaticServer() {
    staticServer_1.staticServer();
}
let restartTimer;
function restartStaticServer() {
    // tslint:disable-next-line: no-unused-expression
    restartTimer && clearTimeout(restartTimer);
    restartTimer = setTimeout(() => {
        staticServer_1.closeExpress();
        startStaticServer();
    }, 500);
}
exports.restartStaticServer = restartStaticServer;
async function isBuildThere(config) {
    const dist = path_1.join(config.homeFolder, config.distFolder);
    if (fs_extra_1.existsSync(dist) && fs_extra_1.existsSync(path_1.join(dist, 'index.html'))) {
        return true;
    }
    console.log(dist, config);
    log_1.logError(`Angular distribution files not found, run "ng build" first`);
    process.exit(15);
}
exports.isBuildThere = isBuildThere;
let wss;
async function enableLiveReloadServer() {
    await config_1.loadConfig();
    try {
        log_1.log('enable reload on port', __1.scullyConfig.reloadPort);
        // tslint:disable-next-line:only-arrow-functions
        wss = new ws_1.Server({ port: __1.scullyConfig.reloadPort, noServer: true });
        wss.on('connection', (client) => {
            client.on('message', (message) => {
                // console.log(`Received message => ${message}`);
            });
            client.send('Hello! Message From Server!!');
        });
    }
    catch (e) {
        log_1.logError(`
-----------------------------------
The port "${log_1.yellow(__1.scullyConfig.reloadPort)}" is not available for the live-reload server.
live reload will not be available. You can configure a different port in the config file.
-----------------------------------`);
    }
    wss = undefined;
}
if (cli_options_1.watch && !cli_options_1.serve) {
    enableLiveReloadServer();
}
function reloadAll() {
    // console.log('send reload');
    if (wss) {
        wss.clients.forEach((client) => client.send('reload'));
    }
}
exports.reloadAll = reloadAll;
function createScript() {
    return `
  <script>
  let wSocket;
  let tries = 0;
  const connect = () => {
    try {
    wSocket = new WebSocket('ws://${__1.scullyConfig.hostName}:${__1.scullyConfig.reloadPort}');
    wSocket.addEventListener('open', () => {
      try {
        wSocket.send('hello');
      } catch (e) {}
    });

    wSocket.addEventListener('message', evt => {
      if (evt && evt.data === 'reload') {
        document.location.reload();
      }
    });

    wSocket.addEventListener('close', () => {
      wSocket = undefined;
      if (++tries < 15) {
        setTimeout(connect, 1500);
      }
    });

    wSocket.addEventListener('error', e => {
      try {
        wSocket.close();
      } catch (e) {}
      wSocket = undefined;
      if (++tries < 15) {
        setTimeout(connect, 1500);
      }
    });
  } catch(e) {
    setTimeout(connect,1500)
  }
  };
  connect();
  </script>
`;
}
exports.createScript = createScript;
//# sourceMappingURL=watchMode.js.map