"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unescapeHtml = exports.WriteStateToStorage = exports.ExtractState = exports.WriteToStorage = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const pluginManagement_1 = require("../pluginManagement");
const pluginConfig_1 = require("../pluginManagement/pluginConfig");
const pluginRepository_1 = require("../pluginManagement/pluginRepository");
const config_1 = require("../utils/config");
const createFolderFor_1 = require("../utils/createFolderFor");
const log_1 = require("../utils/log");
const { writeFile } = fs_1.promises;
const SCULLY_STATE_START = `/** ___SCULLY_STATE_START___ */`;
const SCULLY_STATE_END = `/** ___SCULLY_STATE_END___ */`;
// export const WriteToStorage = '__Scully_WriteToStorage__';
exports.WriteToStorage = Symbol('writeToStorage');
exports.ExtractState = Symbol('ExtractState');
exports.WriteStateToStorage = Symbol('WriteStateToStorage');
/** don't export, let the plugin-system do its work. */
const writeHTMLToFs = async (route, content) => {
    try {
        const file = path_1.join(config_1.scullyConfig.outDir, route, '/index.html');
        createFolderFor_1.createFolderFor(file);
        fs_1.writeFileSync(file, content);
        log_1.log(`Route "${log_1.yellow(route)}" rendered into file: "${log_1.yellow(file)}"`);
    }
    catch (e) {
        log_1.logError(`Error during file write`, e);
    }
};
/** plugin that saves State (if there) to data.json */
const writeDataToFs = async (route, content) => {
    const state = pluginConfig_1.findPlugin(exports.ExtractState)[pluginRepository_1.accessPluginDirectly](route, content);
    if (!config_1.scullyConfig.inlineStateOnly && state) {
        const stateFile = path_1.join(config_1.scullyConfig.outDir, route, '/data.json');
        await writeFile(stateFile, state);
        const dataSize = Math.floor((state.length / 1024) * 100) / 100;
        log_1.log(`${` ${dataSize}Kb`.padStart(12 + route.length, ' ')} data into file: "${log_1.yellow(stateFile)}"`);
        //TODO: add warning for data size?
    }
};
/**
 * Plugin that returns state as string, and return undefined otherwise
 * @param _route
 * @param content
 */
const extractState = (_route, content) => {
    if (!content.includes(SCULLY_STATE_START)) {
        return undefined;
    }
    try {
        return unescapeHtml(content.split(SCULLY_STATE_START)[1].split(SCULLY_STATE_END)[0]);
    }
    catch (e) {
        return undefined;
    }
};
const writeAll = async (route, content) => {
    await writeHTMLToFs(route, content);
    await writeDataToFs(route, content);
};
pluginManagement_1.registerPlugin(pluginManagement_1.scullySystem, exports.WriteToStorage, writeAll);
pluginManagement_1.registerPlugin(pluginManagement_1.scullySystem, exports.ExtractState, extractState);
pluginManagement_1.registerPlugin(pluginManagement_1.scullySystem, exports.WriteStateToStorage, writeDataToFs);
/**
 * Unescape our custom escaped texts
 * @param text
 */
function unescapeHtml(text) {
    const unescapedText = {
        '_~q~': "'",
        '_~b~': '`',
        '_~o~': '$',
        '_~s~': '/',
        '_~l~': '<',
        '_~g~': '>',
    };
    return (text
        /** put back escaped double quotes to make valid json again */
        .replace(/_~d~/g, `\\"`)
        /** replace the custom escapes */
        .replace(/_~[^]~/g, (s) => unescapedText[s])
        /** restore newlines+cr */
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r'));
}
exports.unescapeHtml = unescapeHtml;
//# sourceMappingURL=writeToFs.plugin.js.map