"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.routePluginConfig = exports.setConfig = exports.getConfig = exports.hasPlugin = exports.findPlugin = exports.fetchPlugins = exports.getPluginConfig = exports.setPluginConfig = exports.resetConfig = exports.routeConfigData = exports.backupData = void 0;
const log_1 = require("../utils/log");
const pluginRepository_1 = require("./pluginRepository");
exports.backupData = pluginRepository_1.configData + 'BackupData__';
exports.routeConfigData = pluginRepository_1.configData + 'Route_Config_Data__';
exports.resetConfig = pluginRepository_1.configData + 'resetData__';
exports.setPluginConfig = (name, typeOrConfig, config) => {
    let type;
    // tslint:disable-next-line: no-angle-bracket-type-assertion
    if ((typeof typeOrConfig === 'string' || typeof typeOrConfig === 'symbol') && pluginRepository_1.pluginTypes.includes(typeOrConfig)) {
        type = typeOrConfig;
    }
    else {
        config = typeOrConfig;
    }
    const plugin = findPlugin(name, type);
    exports.setConfig(plugin, config);
};
exports.getPluginConfig = (name, type) => {
    const plugin = findPlugin(name, type);
    return exports.getConfig(plugin);
};
function fetchPlugins(name, type) {
    /** fix for people still caliing utility functions with render type */
    type = type === 'render' ? 'postProcessByHtml' : type;
    const result = Object.entries(pluginRepository_1.plugins)
        /** filter out deprecated render name */
        .filter(([type]) => type !== 'render')
        /** only catch the type that is given, or all */
        .filter(([ofType]) => (!type ? true : ofType === type))
        .map(([_, typedPlugins]) => typedPlugins[name])
        .filter(Boolean);
    return result;
}
exports.fetchPlugins = fetchPlugins;
function findPlugin(name, type, errorOnNotfound = true) {
    const found = fetchPlugins(name, type);
    const displayName = typeof name === 'string' ? name : name.description;
    switch (found.length) {
        case 0:
            if (errorOnNotfound) {
                log_1.logError(`Plugin "${log_1.yellow(displayName)}" of type "${log_1.yellow(type)}" is not found, can not store config`);
                process.exit(15);
            }
            return undefined;
            break;
        case 1:
            return found[0];
        default:
            if (errorOnNotfound) {
                log_1.logError(`Plugin "${log_1.yellow(displayName)}" has multiple types, please specify type to be able to store config`);
                process.exit(15);
            }
            return undefined;
    }
}
exports.findPlugin = findPlugin;
function hasPlugin(name, type) {
    return fetchPlugins(name, type).length === 1;
}
exports.hasPlugin = hasPlugin;
exports.getConfig = (plugin) => {
    const target = plugin.hasOwnProperty(pluginRepository_1.accessPluginDirectly) ? plugin[pluginRepository_1.accessPluginDirectly] : plugin;
    return target[pluginRepository_1.configData] || {};
};
exports.setConfig = (plugin, config) => {
    const target = plugin.hasOwnProperty(pluginRepository_1.accessPluginDirectly) ? plugin[pluginRepository_1.accessPluginDirectly] : plugin;
    target[pluginRepository_1.configData] = Object.assign({}, target[pluginRepository_1.configData] || {}, config);
    target[exports.backupData] = { ...target[pluginRepository_1.configData] };
};
/**
 * @param type
 * @param name
 * @param config
 */
exports.routePluginConfig = (route, name, typeOrConfig, config) => {
    let type;
    // tslint:disable-next-line: no-angle-bracket-type-assertion
    if ((typeof typeOrConfig === 'string' || typeof typeOrConfig === 'symbol') && pluginRepository_1.pluginTypes.includes(typeOrConfig)) {
        type = typeOrConfig;
    }
    else {
        config = typeOrConfig;
    }
    const plugin = findPlugin(name, type);
    plugin[exports.routeConfigData] = plugin[exports.routeConfigData] || {};
    plugin[exports.routeConfigData][route] = Object.assign({}, plugin[pluginRepository_1.configData] || {}, config);
    plugin[exports.resetConfig] = () => {
        plugin[pluginRepository_1.configData] = plugin[exports.backupData];
    };
};
//# sourceMappingURL=pluginConfig.js.map