"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reLaunch = exports.browser = exports.launchedBrowser = exports.launchedBrowser$ = void 0;
const puppeteer_1 = require("puppeteer");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const cli_options_1 = require("../utils/cli-options");
const config_1 = require("../utils/config");
const log_1 = require("../utils/log");
const puppeteerRenderPlugin_1 = require("./puppeteerRenderPlugin");
const launches = new rxjs_1.BehaviorSubject(undefined);
/**
 * Returns an Observable with that will fire with the launched puppeteer in there.
 */
exports.launchedBrowser$ = rxjs_1.of('').pipe(
/** load config only after a subscription is made */
operators_1.switchMap(() => config_1.loadConfig()), 
/** give the system a bit of breathing room, and prevent race */
operators_1.switchMap(() => rxjs_1.from(puppeteerRenderPlugin_1.waitForIt(50))), operators_1.switchMap(() => rxjs_1.merge(obsBrowser(), launches)), 
/** use shareReplay so the browser will stay in memory during the lifetime of the program */
operators_1.shareReplay({ refCount: false, bufferSize: 1 }), operators_1.filter((e) => e !== undefined));
let useageCounter = 0;
exports.launchedBrowser = async () => {
    if (++useageCounter > 500) {
        launches.next();
        useageCounter = 0;
    }
    return exports.launchedBrowser$.pipe(operators_1.take(1)).toPromise();
};
/** ICE relaunch puppeteer. */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
exports.reLaunch = (reason) => {
    //   if (reason) {
    //     logWarn(
    //       white(`
    // ========================================
    //     Relaunch because of ${reason}
    // ========================================
    //     `)
    //     );
    //   }
    launches.next();
    return exports.launchedBrowser();
};
/**
 * Function that creates an observable with the puppeteer browser inside
 * @param options
 */
function obsBrowser(options = config_1.scullyConfig.puppeteerLaunchOptions || {}) {
    if (cli_options_1.showBrowser) {
        options.headless = false;
    }
    options.ignoreHTTPSErrors = true;
    options.args = options.args || [];
    // options.args = ['--no-sandbox', '--disable-setuid-sandbox'];
    const { SCULLY_PUPPETEER_EXECUTABLE_PATH } = process.env;
    if (SCULLY_PUPPETEER_EXECUTABLE_PATH) {
        log_1.log(`Launching puppeteer with executablePath ${SCULLY_PUPPETEER_EXECUTABLE_PATH}`);
        options.executablePath = SCULLY_PUPPETEER_EXECUTABLE_PATH;
        options.args = [...options.args, '--disable-dev-shm-usage'];
    }
    let isLaunching = false;
    return new rxjs_1.Observable((obs) => {
        const startPupetteer = () => {
            if (!isLaunching) {
                isLaunching = true;
                launchPuppeteerWithRetry(options).then((b) => {
                    /** I will only come here when puppeteer is actually launched */
                    exports.browser = b;
                    b.on('disconnected', () => exports.reLaunch('disconnect'));
                    obs.next(b);
                    /** only allow a relaunch in a next cycle */
                    setTimeout(() => (isLaunching = false), 1000);
                });
            }
        };
        launches
            .pipe(
        /** ignore request while the browser is already starting, we can only launch 1 */
        operators_1.filter(() => !isLaunching), 
        /** the long throttleTime is to cater for the concurrently running browsers to crash and burn. */
        operators_1.throttleTime(15000), 
        // provide enough time for the current async operations to finish before killing the current browser instance
        operators_1.delayWhen(() => rxjs_1.merge(
        /** timout at 25 seconds */
        rxjs_1.timer(25000), 
        /** or then the number of pages hits <=1  */
        rxjs_1.interval(500).pipe(
        /** if the browser is active get the pages promise */
        operators_1.switchMap(() => (exports.browser ? exports.browser.pages() : rxjs_1.of([]))), 
        /** only go ahead when there is <=1 pages (the browser itself) */
        operators_1.filter((p) => exports.browser === undefined || p.length <= 1))).pipe(
        /** use take 1 to make sure we complete when one of the above fires */
        operators_1.take(1), 
        /** if something _really_ unwieldy happens with the browser, ignore and go ahead */
        operators_1.catchError(() => rxjs_1.of([])))))
            .subscribe({
            next: () => {
                try {
                    if (exports.browser && exports.browser.process() != null) {
                        exports.browser.process().kill('SIGINT');
                    }
                }
                catch (_a) {
                    /** ignored */
                }
                startPupetteer();
            },
        });
        return () => {
            if (exports.browser) {
                exports.browser.close();
                exports.browser = undefined;
            }
        };
    });
}
/**
 * Helper to try launching pupteer, tries 3 times, and then exits on failure.
 * it also features an timeout, for when puppeteer silently fails
 * @param options Puppeteer launch options
 * @param failedLaunches number of retries.
 * @returns promise<Browser>
 */
function launchPuppeteerWithRetry(options, failedLaunches = 0) {
    const timeout = (millisecs) => new Promise((_, reject) => setTimeout(() => reject('timeout'), millisecs));
    return Promise.race([
        /** use a 1 minute timeout to detect a stalled launch of puppeteer */
        timeout(Math.max(/** serverTimeout,*/ 60 * 1000)),
        puppeteer_1.launch(options).then((b) => {
            return b;
        }),
    ])
        .catch((e) => {
        /** first stage catch check for retry */
        if (e.message.includes('Could not find browser revision')) {
            throw new Error('Failed launch');
        }
        if (++failedLaunches < 3) {
            return launchPuppeteerWithRetry(options, failedLaunches);
        }
        throw new Error('failed 3 times to launch');
    })
        .catch((b) => {
        /** second stage catch, houston, we have a problem, and will abort */
        log_1.logError(`
=================================================================================================
Puppeteer cannot find or launch the browser. (by default chrome)
 Try adding 'puppeteerLaunchOptions: {executablePath: CHROMIUM_PATH}'
 to your scully.*.config.ts file.
Also, this might happen because the default timeout (60 seconds) is to short on this system
this can be fixed by adding the ${log_1.yellow('--serverTimeout=x')} cmd line option.
   (where x = the new timeout in milliseconds)
When this happens in CI/CD you can find some additional information here:
https://github.com/puppeteer/puppeteer/blob/main/docs/troubleshooting.md
=================================================================================================
      `);
        process.exit(15);
    });
}
//# sourceMappingURL=launchedBrowser.js.map