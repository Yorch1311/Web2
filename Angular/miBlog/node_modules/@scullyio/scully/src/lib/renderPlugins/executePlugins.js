"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderRoute = void 0;
const pluginConfig_1 = require("../pluginManagement/pluginConfig");
const pluginRepository_1 = require("../pluginManagement/pluginRepository");
const config_1 = require("../utils/config");
const log_1 = require("../utils/log");
const captureMessage_1 = require("../utils/captureMessage");
const puppeteerRenderPlugin_1 = require("./puppeteerRenderPlugin");
const jsdomPlugins_1 = require("./jsdomPlugins");
exports.renderRoute = Symbol('renderRoute');
const executePluginsForRoute = async (route) => {
    /** make one array with all handlers for this route, filter out empty ones */
    const handlers = [route.type, ...(route.postRenderers || config_1.scullyConfig.defaultPostRenderers)].filter(Boolean);
    const preRender = route.config && route.config.preRenderer;
    if (preRender) {
        try {
            const prResult = await preRender(route);
            if (prResult === false) {
                log_1.logWarn(`The prerender function stopped rendering for "${log_1.yellow(route.route)}". This route is skipped.`);
                return '';
            }
        }
        catch (e) {
            captureMessage_1.captureException(e);
            log_1.logError(`The prerender function did error during rendering for "${log_1.yellow(route.route)}". This route is skipped.`);
            /** abort when prerender throws */
            return '';
        }
    }
    // this support different renders: puppeteer / imgRender / universal / others...
    const InitialHTML = (await (route.renderPlugin ? pluginConfig_1.findPlugin(route.renderPlugin) : pluginConfig_1.findPlugin(puppeteerRenderPlugin_1.puppeteerRender))(route));
    // split out jsDom vs string renderers.
    const { jsDomRenders, renders: stringRenders } = handlers.reduce((result, plugin) => {
        const textHandler = pluginConfig_1.findPlugin(plugin, 'postProcessByHtml', false);
        if (textHandler !== undefined) {
            result.renders.push({ plugin, handler: textHandler });
        }
        const jsDomHandler = pluginConfig_1.findPlugin(plugin, 'postProcessByDom', false);
        if (jsDomHandler !== undefined) {
            result.jsDomRenders.push({ plugin, handler: jsDomHandler });
        }
        return result;
    }, { jsDomRenders: [], renders: [] });
    /** render jsDOM plugins before the text plugins.  */
    let jsDomHtml;
    if (jsDomRenders.length > 0) {
        const startDom = pluginConfig_1.findPlugin(jsdomPlugins_1.toJSDOM)(InitialHTML);
        const endDom = await jsDomRenders.reduce(async (dom, { handler, plugin }) => {
            const d = await dom;
            try {
                /** return result of plugin */
                return handler(d, route);
            }
            catch (e) {
                captureMessage_1.captureException(e);
                log_1.logError(`Error during content generation with plugin "${log_1.yellow(plugin)}" for ${log_1.yellow(route.templateFile)}. This hander is skipped.
          ${e.message}

          `);
                /** reset jsDOM to initial state, as we now probably have an unknown state. */
                return pluginConfig_1.findPlugin(jsdomPlugins_1.toJSDOM)(InitialHTML);
            }
        }, startDom);
        jsDomHtml = await pluginConfig_1.findPlugin(jsdomPlugins_1.fromJSDOM)(endDom);
    }
    /** render all the text render plugins */
    return stringRenders.reduce(async (updatedHTML, { handler, plugin }) => {
        const html = await updatedHTML;
        try {
            /** return result of plugin */
            return await handler(html, route);
        }
        catch (e) {
            captureMessage_1.captureException(e);
            log_1.logError(`Error during content generation with plugin "${log_1.yellow(plugin)}" for ${log_1.yellow(route.templateFile)}. This hander is skipped.`);
        }
        /** return unhandled result */
        return html;
    }, Promise.resolve(jsDomHtml || InitialHTML));
};
pluginRepository_1.registerPlugin(pluginRepository_1.scullySystem, exports.renderRoute, executePluginsForRoute);
//# sourceMappingURL=executePlugins.js.map