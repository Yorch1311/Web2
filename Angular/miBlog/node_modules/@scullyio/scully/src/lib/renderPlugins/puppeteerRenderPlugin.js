"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForIt = exports.puppeteerRender = void 0;
// tslint:disable: no-string-literal
// const puppeteer = require('puppeteer');
const fs_extra_1 = require("fs-extra");
const jsonc_1 = require("jsonc");
const path_1 = require("path");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const pluginManagement_1 = require("../pluginManagement");
const utils_1 = require("../utils");
const cli_options_1 = require("../utils/cli-options");
const config_1 = require("../utils/config");
const log_1 = require("../utils/log");
const captureMessage_1 = require("../utils/captureMessage");
const title404_1 = require("../utils/serverstuff/title404");
const launchedBrowser_1 = require("./launchedBrowser");
const errorredPages = new Map();
let version = '0.0.0';
try {
    const pkg = path_1.join(__dirname, '../../../package.json');
    // console.log(pkg)
    version = jsonc_1.jsonc.parse(fs_extra_1.readFileSync(pkg).toString()).version || '0.0.0';
}
catch (e) {
    // this is only for internals builds
    // version = jsonc.parse(readFileSync(join(__dirname, '../../../package.json')).toString()).version || '0.0.0';
}
exports.puppeteerRender = Symbol('puppeteerRender');
const plugin = async (route) => {
    const timeOutValueInSeconds = 25;
    const pageLoaded = new rxjs_1.Subject();
    const path = route.rawRoute
        ? route.rawRoute
        : config_1.scullyConfig.hostUrl
            ? `${config_1.scullyConfig.hostUrl}${route.route}`
            : `http${cli_options_1.ssl ? 's' : ''}://${config_1.scullyConfig.hostName}:${config_1.scullyConfig.appPort}${route.route}`;
    let pageHtml;
    let browser;
    let page;
    try {
        browser = await launchedBrowser_1.launchedBrowser().catch((e) => {
            log_1.logError('Pupeteer died?', e);
            captureMessage_1.captureException(e);
            return Promise.reject(e);
        });
        // open a new page
        page = await browser.newPage();
        let resolve;
        const pageReady = new Promise((r) => (resolve = r));
        if (config_1.scullyConfig.bareProject) {
            await page.setRequestInterception(true);
            page.on('request', registerRequest);
            page.on('requestfinished', unRegisterRequest);
            page.on('requestfailed', unRegisterRequest);
            const requests = new Set();
            // eslint-disable-next-line no-inner-declarations
            function registerRequest(request) {
                request.continue();
                requests.add(requests);
            }
            // eslint-disable-next-line no-inner-declarations
            function unRegisterRequest(request) {
                // request.continue();
                requests.delete(requests);
            }
            pageLoaded
                .pipe(operators_1.switchMap(() => rxjs_1.interval(50)), operators_1.filter(() => requests.size === 0), operators_1.filter(() => route.config && route.config.manualIdleCheck), operators_1.take(1))
                .subscribe({
                complete: () => {
                    console.log('page should be idle');
                    resolve();
                },
            });
        }
        if (config_1.scullyConfig.ignoreResourceTypes && config_1.scullyConfig.ignoreResourceTypes.length > 0) {
            await page.setRequestInterception(true);
            page.on('request', checkIfRequestShouldBeIgnored);
            // eslint-disable-next-line no-inner-declarations
            function checkIfRequestShouldBeIgnored(request) {
                if (config_1.scullyConfig.ignoreResourceTypes.includes(request.resourceType())) {
                    request.abort();
                }
                else {
                    request.continue();
                }
            }
        }
        /** this will be called from the browser, but runs in node */
        await page.exposeFunction('onCustomEvent', () => {
            resolve();
        });
        windowSet(page, 'scullyVersion', version);
        if (route.config && route.config.manualIdleCheck) {
            // windowSet(page, 'ScullyIO-ManualIdle', true);
            route.exposeToPage = route.exposeToPage || {};
            route.exposeToPage.manualIdle = true;
        }
        if (config_1.scullyConfig.inlineStateOnly) {
            route.injectToPage = route.injectToPage || {};
            route.injectToPage.inlineStateOnly = true;
        }
        if (route.exposeToPage !== undefined) {
            windowSet(page, 'ScullyIO-exposed', route.exposeToPage);
        }
        if (route.injectToPage !== undefined) {
            windowSet(page, 'ScullyIO-injected', route.injectToPage);
        }
        /** Inject this into the running page, runs in browser */
        await page.evaluateOnNewDocument(() => {
            /** set "running" mode */
            window['ScullyIO'] = 'running';
            window.addEventListener('AngularReady', () => {
                window['onCustomEvent']();
            });
        });
        // enter url in page
        await page.goto(path);
        pageLoaded.next();
        await Promise.race([pageReady, waitForIt(timeOutValueInSeconds * 1000)]);
        /** when done, add in some scully content. */
        await page.evaluate(() => {
            const head = document.head;
            /** add a small script tag to set "generated" mode */
            const d = document.createElement('script');
            d.innerHTML = `window['ScullyIO']='generated';`;
            if (window['ScullyIO-injected']) {
                /** and add the injected data there too. */
                d.innerHTML += `window['ScullyIO-injected']=${JSON.stringify(window['ScullyIO-injected'])};`;
            }
            const m = document.createElement('meta');
            m.name = 'generator';
            m.content = `Scully ${window['scullyVersion']}`;
            head.appendChild(d);
            head.insertBefore(m, head.firstChild);
            /** inject the scully version into the body attribute */
            document.body.setAttribute('scully-version', window['scullyVersion']);
        });
        pageHtml = await page.content();
        /** Check for undefined content and re-try */
        if ([undefined, null, '', 'undefined', 'null'].includes(pageHtml)) {
            throw new Error(`Route "${route.route}" render to ${path}`);
        }
        const firstTitle = await page.evaluate(() => {
            const d = document.querySelector('h1');
            return (d && d.innerText) || '';
        });
        if (firstTitle === title404_1.title404) {
            log_1.logWarn(`Route "${log_1.yellow(route.route)}" not provided by angular app`);
        }
        /** save thumbnail to disk code */
        if (config_1.scullyConfig.thumbnails) {
            const file = path_1.join(config_1.scullyConfig.outDir, route.route, '/thumbnail.jpg');
            utils_1.createFolderFor(file);
            await page.screenshot({ path: file });
        }
        // pageHtml = await page.evaluate(`(async () => {
        //   return new XMLSerializer().serializeToString(document.doctype) + document.documentElement.outerHTML
        // })()`);
        /**
         * when the browser is shown, use a 2 minute timeout, otherwise
         * wait for page-read || timeout @ 25 seconds.
         */
        if (cli_options_1.showBrowser) {
            // if (false) {
            page.evaluate("console.log('\\n\\n------------------------------\\nScully is done, page left open for 120 seconds for inspection\\n------------------------------\\n\\n')");
            //* don't close the browser, but leave it open for inspection for 120 secs
            waitForIt(120 * 1000).then(() => page.close());
        }
        else {
            await page.close();
        }
    }
    catch (err) {
        const { message } = err;
        // tslint:disable-next-line: no-unused-expression
        page && typeof page.close === 'function' && (await page.close());
        log_1.logWarn(`Puppeteer error while rendering "${log_1.yellow(route.route)}"`, err, ' we will retry rendering this page up to 3 times.');
        if (message && message.includes('closed')) {
            /** signal the launched to relaunch puppeteer, as it has likely died here. */
            launchedBrowser_1.reLaunch('closed');
            // return puppeteerRender(route);
        }
        if (errorredPages.has(route.route) && errorredPages.get(route.route) > 2) {
            log_1.logError(`Puppeteer error while rendering "${log_1.yellow(route.route)}"`, err, ' we retried rendering this page 3 times.');
            /** we tried this page before, something is really off. Exit stage left. */
            captureMessage_1.captureException(err);
            process.exit(15);
        }
        else {
            const count = errorredPages.get(route.route) || 0;
            errorredPages.set(route.route, count + 1);
            /** give it a couple of secs */
            await waitForIt(3 * 1000);
            /** retry! */
            return plugin(route);
        }
    }
    return pageHtml;
};
function waitForIt(milliSeconds) {
    return new Promise((resolve) => setTimeout(() => resolve(), milliSeconds));
}
exports.waitForIt = waitForIt;
const windowSet = (page, name, value) => page.evaluateOnNewDocument(`
    Object.defineProperty(window, '${name}', {
      get() {
        return JSON.parse('${JSON.stringify(value)}')
      }
    })
  `);
pluginManagement_1.registerPlugin(pluginManagement_1.scullySystem, exports.puppeteerRender, plugin);
//# sourceMappingURL=puppeteerRenderPlugin.js.map