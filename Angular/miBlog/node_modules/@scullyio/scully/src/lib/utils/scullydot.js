"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.askUser = exports.getFingerPrint = exports.writeDotProperty = exports.readDotProperty = exports.dotFolder = void 0;
const crypto_1 = require("crypto");
const fs_1 = require("fs");
const fs_extra_1 = require("fs-extra");
const js_yaml_1 = require("js-yaml");
const path_1 = require("path");
const readline_1 = require("readline");
const createFolderFor_1 = require("./createFolderFor");
const cli_options_1 = require("./cli-options");
const log_1 = require("./log");
exports.dotFolder = path_1.join(__dirname, '../../../../../../', '.scully/');
const state = {
    dotProps: undefined,
};
/**
 * Read a property from the scully dotfile/settings
 * @param propName
 */
exports.readDotProperty = (propName) => {
    if (!state.dotProps) {
        const file = path_1.join(exports.dotFolder, 'settings.yml'); //?
        if (!fs_extra_1.existsSync(file)) {
            return undefined;
        }
        state.dotProps = js_yaml_1.safeLoad(fs_extra_1.readFileSync(file).toString('utf-8'));
    }
    return state.dotProps[propName];
};
/**
 * write a property to the scully dotfile/settings
 * @param propName
 * @param value
 */
exports.writeDotProperty = (propName, value) => {
    if (!state.dotProps) {
        state.dotProps = {};
    }
    state.dotProps[propName] = value;
    const file = path_1.join(exports.dotFolder, 'settings.yml'); //?
    createFolderFor_1.createFolderFor(file);
    fs_1.writeFileSync(file, js_yaml_1.safeDump(state.dotProps));
};
exports.getFingerPrint = () => {
    var _a;
    if ((_a = state === null || state === void 0 ? void 0 : state.dotProps) === null || _a === void 0 ? void 0 : _a.identifier) {
        return state.dotProps.identifier;
    }
    const identifier = exports.readDotProperty('identifier');
    if (!identifier) {
        exports.writeDotProperty('identifier', createIndefier());
    }
    return state.dotProps.identifier;
};
exports.getFingerPrint(); //?
function createIndefier() {
    const st = crypto_1.randomBytes(4).toString('hex');
    /** merge the exact time with random chars to create an unique identifier */
    return Date.now()
        .toString(36)
        .split('')
        .map((token, i) => token + st[i])
        .join('');
}
/**
 * Utility function to ask for user input, takes a string that will be displayed as prompt.
 * returns a promise with tha answer of the user, or undefined if its in CI/ --noPrompt option
 * @param question
 */
exports.askUser = (question) => {
    return new Promise((resolve, reject) => {
        var _a;
        if (cli_options_1.noPrompt || ((_a = process.stdout) === null || _a === void 0 ? void 0 : _a.cursorTo) === undefined) {
            return resolve(undefined);
        }
        const rl = readline_1.createInterface({
            input: process.stdin,
            output: process.stdout,
        });
        log_1.log(log_1.white(`(You can skip this, or any future question by using the --noPrompt flag)`));
        rl.question(question, (a) => {
            resolve(a);
            rl.close();
        });
    });
};
//# sourceMappingURL=scullydot.js.map