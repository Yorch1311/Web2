"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processRoutes = void 0;
const perf_hooks_1 = require("perf_hooks");
const pluginManagement_1 = require("../../pluginManagement");
const storeRoutes_1 = require("../../systemPlugins/storeRoutes");
const cli_options_1 = require("../cli-options");
const log_1 = require("../log");
const performanceIds_1 = require("../performanceIds");
exports.processRoutes = Symbol('processRoutes');
async function processRoutesPlugin(routes) {
    perf_hooks_1.performance.mark('startRouteProcess');
    performanceIds_1.performanceIds.add('RouteProcess');
    let result;
    try {
        result = await Object.values(pluginManagement_1.plugins.routeProcess)
            .sort((a, b) => (a[pluginManagement_1.accessPluginDirectly][pluginManagement_1.routeProcessPriority] < b[pluginManagement_1.accessPluginDirectly][pluginManagement_1.routeProcessPriority] ? -1 : 1))
            .reduce(async (previousRoutes, routeProcessor) => {
            return await routeProcessor(await previousRoutes);
        }, Promise.resolve(routes));
    }
    catch (e) {
        log_1.logError(`Problem during route processing, see below for details. Skipped changing routes`);
        console.error(e);
        result = routes;
    }
    /** save routerinfo, so its available during rendering */
    if (cli_options_1.baseFilter === '' && cli_options_1.routeFilter === '') {
        /** only store when the routes are complete  */
        await pluginManagement_1.findPlugin(storeRoutes_1.storeRoutes)(result);
    }
    perf_hooks_1.performance.mark('stopRouteProcess');
    return result;
}
pluginManagement_1.registerPlugin(pluginManagement_1.scullySystem, exports.processRoutes, processRoutesPlugin);
//# sourceMappingURL=processRoutes.js.map