"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleUnknownRoute = void 0;
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const __1 = require("..");
const pluginManagement_1 = require("../../pluginManagement");
const storeRoutes_1 = require("../../systemPlugins/storeRoutes");
const cli_options_1 = require("../cli-options");
const log_1 = require("../log");
const path_to_regexp_1 = require("path-to-regexp");
const title404_1 = require("./title404");
const config_1 = require("../config");
exports.handleUnknownRoute = async (req, res, next) => {
    if (req.accepts('html')) {
        /** only handle 404 on html requests specially  */
        await config_1.loadConfig();
        const distFolder = path_1.join(__1.scullyConfig.homeFolder, __1.scullyConfig.hostFolder || __1.scullyConfig.distFolder);
        const distIndex = path_1.join(distFolder, '/index.html');
        const dist404 = path_1.join(distFolder, '/404.html');
        // cmd-line takes precedence over config
        const h404 = (cli_options_1.handle404.trim() === '' ? __1.scullyConfig.handle404 : cli_options_1.handle404).trim().toLowerCase();
        switch (h404) {
            case '':
                /** checks if the path is in the scully.routes */
                const myHandledRoutes = loadHandledRoutes();
                if (myHandledRoutes.includes(req.url)) {
                    return res.sendFile(distIndex);
                }
                break;
            case 'onlybase':
            case 'baseonly':
                /** checks if the path has a unhandled route that fits */
                const unhandledRoutes = await pluginManagement_1.findPlugin(__1.handleTravesal)();
                if (unhandledRoutes.find(matchRoute(req))) {
                    /** this is a base route known by Scully, just return the index */
                    return res.sendFile(distIndex);
                }
                /** use fallthrough as all of those are served by the above route-machers, and only here if the route is 404 */
                break;
            case 'index':
                /** don't care, always send the index.html */
                return res.sendFile(distIndex);
            case '404':
                /** don't care, always send the 404.html */
                return res.sendFile(dist404);
            case 'none':
                /** let express do its default thing, don't alter behavior */
                return next();
            default:
                log_1.logError(`the option "${log_1.yellow(h404)}" is not a valid 404 option`);
                process.exit(15);
        }
        res.status(404);
        return res.send(`
        <h1>${title404_1.title404}</h1>
        <p>The url "${req.url}" is not provided in the scully.routes.json, so it can't be generated</p>
        <p>If you have routes that are not known before  you might want to serve index.html instead of this response. <br> That can be done by adding the '--404=index' option to the Scully command
        <script>
          /** triggering page ready, as there is no need to wait for a timeout */
          setTimeout(() => window.dispatchEvent(new Event('AngularReady', {
            bubbles: true,
            cancelable: false
          })),10)
        </script>
    `);
    }
    else {
        log_1.logWarn(`Resource not found:"${log_1.yellow(req.url)}"`);
    }
    next();
};
/** helper function to match paths to their unhandled that might include vars and stars */
function matchRoute(req) {
    return (route) => {
        try {
            const path = req.url;
            if (route.endsWith('**') && route.length > 3) {
                /** handle angular wildcard route but exclude the `/**`  */
                const base = route.slice(0, route.length - 3);
                return path.startsWith(base);
            }
            else {
                /** use the routematcher express is using */
                const regex = path_to_regexp_1.pathToRegexp(route);
                const match = regex.test(path);
                return match;
            }
        }
        catch (e) {
            /** something blew up with unexpected paths/routes means -no match anyway */
            // console.log(req.url, r);
        }
        return false;
    };
}
let lastTime = 0;
const handledRoutes = new Set();
function loadHandledRoutes() {
    const path = path_1.join(__1.scullyConfig.outDir, storeRoutes_1.routesFileName);
    const tdLastModified = fs_extra_1.statSync(path).mtimeMs;
    if (lastTime < tdLastModified) {
        try {
            const routes = JSON.parse(fs_extra_1.readFileSync(path, 'utf-8').toString());
            handledRoutes.clear();
            routes.forEach((r) => handledRoutes.add(r.route));
            lastTime = tdLastModified;
        }
        catch (e) {
            log_1.logWarn('Error parsing route file', e);
        }
    }
    return Array.from(handledRoutes.values());
}
//# sourceMappingURL=handleUnknownRoute.js.map