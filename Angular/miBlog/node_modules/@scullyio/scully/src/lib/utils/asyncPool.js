"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.asyncPool = void 0;
const puppeteerRenderPlugin_1 = require("../renderPlugins/puppeteerRenderPlugin");
const log_1 = require("./log");
const perf_hooks_1 = require("perf_hooks");
const progressTime = 100;
/**
 * takes an array, and runs **MaxParalellTasks** in paralell until all tasks are node
 * @param MaxParalellTasks
 * @param array
 * @param taskFn
 */
async function asyncPool(MaxParalellTasks, array, taskFn) {
    const ret = [];
    const executing = [];
    let logTime = perf_hooks_1.performance.now();
    for (const item of array) {
        const p = taskFn(item);
        ret.push(p);
        const e = p.then(() => executing.splice(executing.indexOf(e), 1));
        e['item'] = item;
        executing.push(e);
        const now = perf_hooks_1.performance.now();
        if (now - logTime > progressTime) {
            const tasksLeft = Math.max(array.length - ret.length, executing.length);
            log_1.printProgress(array.length + 1 - tasksLeft, 'Rendering Routes:', array.length);
            logTime = now;
        }
        if (executing.length >= MaxParalellTasks) {
            await Promise.race(executing);
        }
    }
    while (executing.length > 0) {
        /** inform used tasks are still running. */
        await Promise.race([...executing, puppeteerRenderPlugin_1.waitForIt(progressTime)]);
    }
    log_1.printProgress(array.length, 'Rendering Routes:', array.length);
    return Promise.all(ret);
}
exports.asyncPool = asyncPool;
function logit(x) {
    x.forEach((p) => log_1.logWarn(p['item'].route));
}
//# sourceMappingURL=asyncPool.js.map