"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.proxyAdd = void 0;
/* eslint-disable @typescript-eslint/no-var-requires */
const fs_1 = require("fs");
const path_1 = require("path");
const cli_options_1 = require("../cli-options");
const config_1 = require("../config");
const log_1 = require("../log");
const http_proxy_middleware_1 = require("http-proxy-middleware");
exports.proxyAdd = (server) => {
    const proxyConfig = loadProxyConfig();
    if (proxyConfig) {
        setupProxy(proxyConfig, server);
    }
};
function loadProxyConfig() {
    if (typeof config_1.scullyConfig.proxyConfig !== 'string' && cli_options_1.proxyConfigFile === undefined) {
        return undefined;
    }
    /** cmdLine has priority */
    const configFile = cli_options_1.proxyConfigFile || config_1.scullyConfig.proxyConfig;
    const proxyPath = path_1.join(config_1.scullyConfig.homeFolder, configFile);
    if (fs_1.existsSync(proxyPath)) {
        try {
            const proxy = setupProxyFeature(require(proxyPath));
            log_1.log(`Proxy config loaded from "${proxyPath}"`);
            return proxy;
        }
        catch (_a) {
            log_1.logError(`
Error while reading proxy config file "${log_1.yellow(proxyPath)}"
      `);
        }
    }
    else {
        log_1.logError(`
Proxy config file "${log_1.yellow(proxyPath)}" is not found
          `);
    }
    process.exit(15);
}
function setupProxyFeature(rawOptions) {
    /**
     * Assume a proxy configuration specified as:
     * proxy: {
     *   'context': { options }
     * }
     * OR
     * proxy: {
     *   'context': 'target'
     * }
     */
    if (!Array.isArray(rawOptions)) {
        if (Object.prototype.hasOwnProperty.call(rawOptions, 'target')) {
            return [rawOptions];
        }
        else {
            return Object.keys(rawOptions).map((context) => {
                let proxyOptions;
                // For backwards compatibility reasons.
                const correctedContext = context.replace(/^\*$/, '**').replace(/\/\*$/, '');
                if (typeof rawOptions[context] === 'string') {
                    proxyOptions = {
                        context: correctedContext,
                        target: rawOptions[context],
                    };
                }
                else {
                    proxyOptions = Object.assign({}, rawOptions[context]);
                    proxyOptions.context = correctedContext;
                }
                proxyOptions.logLevel = proxyOptions.logLevel || 'warn';
                return proxyOptions;
            });
        }
    }
    return rawOptions;
}
const getProxyMiddleware = (proxyConfig) => {
    const context = proxyConfig.context || proxyConfig.path;
    // It is possible to use the `bypass` method without a `target`.
    // However, the proxy middleware has no use in this case, and will fail to instantiate.
    log_1.log('blah', context, proxyConfig.target);
    if (proxyConfig.target) {
        // eslint-disable-next-line
        return http_proxy_middleware_1.createProxyMiddleware(context, proxyConfig);
    }
};
function setupProxy(configArray, server) {
    /**
     * Assume a proxy configuration specified as:
     * proxy: [
     *   {
     *     context: ...,
     *     ...options...
     *   },
     *   // or:
     *   function() {
     *     return {
     *       context: ...,
     *       ...options...
     *     };
     *   }
     * ]
     */
    configArray.forEach((proxyConfigOrCallback) => {
        let proxyMiddleware;
        let proxyConfig = typeof proxyConfigOrCallback === 'function' ? proxyConfigOrCallback() : proxyConfigOrCallback;
        proxyMiddleware = getProxyMiddleware(proxyConfig);
        const handle = (req, res, next) => {
            if (typeof proxyConfigOrCallback === 'function') {
                const newProxyConfig = proxyConfigOrCallback();
                if (newProxyConfig !== proxyConfig) {
                    proxyConfig = newProxyConfig;
                    proxyMiddleware = getProxyMiddleware(proxyConfig);
                }
            }
            // - Check if we have a bypass function defined
            // - In case the bypass function is defined we'll retrieve the
            // bypassUrl from it otherwise bypassUrl would be null
            const isByPassFuncDefined = typeof proxyConfig.bypass === 'function';
            const bypassUrl = isByPassFuncDefined ? proxyConfig.bypass(req, res, proxyConfig) : null;
            if (typeof bypassUrl === 'boolean') {
                // skip the proxy
                req.url = null;
                next();
            }
            else if (typeof bypassUrl === 'string') {
                // byPass to that url
                req.url = bypassUrl;
                next();
            }
            else if (proxyMiddleware) {
                return proxyMiddleware(req, res, next);
            }
            else {
                next();
            }
        };
        server.use(handle);
        // Also forward error requests to the proxy so it can handle them.
        server.use((error, req, res, next) => handle(req, res, next));
    });
}
//# sourceMappingURL=proxyAdd.js.map