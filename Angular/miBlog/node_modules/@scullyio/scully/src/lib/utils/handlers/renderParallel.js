"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderParallel = void 0;
const perf_hooks_1 = require("perf_hooks");
const pluginConfig_1 = require("../../pluginManagement/pluginConfig");
const executePlugins_1 = require("../../renderPlugins/executePlugins");
const puppeteerRenderPlugin_1 = require("../../renderPlugins/puppeteerRenderPlugin");
const writeToFs_plugin_1 = require("../../systemPlugins/writeToFs.plugin");
const asyncPool_1 = require("../asyncPool");
const config_1 = require("../config");
const log_1 = require("../log");
const performanceIds_1 = require("../performanceIds");
const writeToFs = pluginConfig_1.findPlugin(writeToFs_plugin_1.WriteToStorage);
const reThrow = (e) => {
    throw new Error(e);
};
const executePluginsForRoute = pluginConfig_1.findPlugin(executePlugins_1.renderRoute);
async function renderParallel(dataRoutes) {
    const routeRender = (route, tries = 0) => Promise.race([
        executePluginsForRoute(route),
        /** sometimes puppeteer just dies without error or completing, this will kill the render after 1.5 minute (takes in account that some pages are _slow_) */
        puppeteerRenderPlugin_1.waitForIt(90 * 1000).then(() => {
            throw new Error(`timeout on ${route.route}`);
        }),
    ])
        .catch(async (e) => {
        if (tries > 0) {
            /** don't log on first error, puppeteer is flakey, just retry without notifying dev  */
            log_1.logWarn(`  route: ${route.route}. Try ${tries} failed with ${e}`);
        }
        return tries < 3 ? routeRender(route, tries + 1) : reThrow(e);
    })
        .then((html) => html && writeToFs(route.route, html));
    perf_hooks_1.performance.mark('startRender');
    performanceIds_1.performanceIds.add('Render');
    let renderPool = [];
    try {
        renderPool = await asyncPool_1.asyncPool(config_1.scullyConfig.maxRenderThreads, dataRoutes, routeRender);
    }
    catch (e) {
        console.log('oops during rendering?', e);
    }
    perf_hooks_1.performance.mark('stopRender');
    return renderPool;
}
exports.renderParallel = renderParallel;
//# sourceMappingURL=renderParallel.js.map