"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startScully = void 0;
/* eslint-disable @typescript-eslint/no-use-before-define */
const perf_hooks_1 = require("perf_hooks");
const pluginManagement_1 = require("../pluginManagement");
const watchMode_1 = require("../watchMode");
const captureMessage_1 = require("./captureMessage");
const cli_options_1 = require("./cli-options");
const config_1 = require("./config");
const defaultAction_1 = require("./handlers/defaultAction");
const log_1 = require("./log");
const performanceIds_1 = require("./performanceIds");
const scullydot_1 = require("./scullydot");
const path_1 = require("path");
const fs_1 = require("fs");
/**
 * Starts the entire process
 * @param config:ScullyConfig
 */
exports.startScully = async (url) => {
    /** any question to ask to user, do it here. After this place, the parallel task prohibit proper entry */
    if (scullydot_1.readDotProperty('allowErrorCollect') === undefined) {
        const answer = await scullydot_1.askUser('Would you allow Scully to collect anonymous errors to improve our services? (Y/n)');
        if (answer !== undefined) {
            scullydot_1.writeDotProperty('allowErrorCollect', answer.trim().toLowerCase().startsWith('y') || answer.trim() === '');
        }
    }
    log_1.startProgress();
    log_1.printProgress(false, 'warming up');
    return new Promise((resolve) => {
        perf_hooks_1.performance.mark('startDuration');
        performanceIds_1.performanceIds.add('Duration');
        let innerResolve;
        const durationProm = new Promise((r) => (innerResolve = r));
        const obs = new perf_hooks_1.PerformanceObserver(measurePerformance(innerResolve));
        obs.observe({ entryTypes: ['measure'], buffered: true });
        const numberOfRoutesProm = pluginManagement_1.findPlugin(defaultAction_1.generateAll)(url)
            .then((routes) => {
            log_1.printProgress(false, 'calculate timings');
            perf_hooks_1.performance.mark('stopDuration');
            /** measure all performance checks */
            try {
                const i = performanceIds_1.performanceIds.size;
                for (const id of performanceIds_1.performanceIds) {
                    perf_hooks_1.performance.measure(id, `start${id}`, `stop${id}`);
                }
            }
            catch (e) {
                console.error(e);
                captureMessage_1.captureException(e);
            }
            return routes.length;
        })
            .catch(() => 0);
        Promise.all([numberOfRoutesProm, durationProm]).then(([numberOfRoutes, durations]) => resolve({ numberOfRoutes, durations }));
    }).then(({ numberOfRoutes, durations }) => {
        const duration = durations.Duration;
        // tslint:disable-next-line:variable-name
        const seconds = duration / 1000;
        const singleTime = duration / numberOfRoutes;
        const routesProSecond = Math.ceil((1000 / singleTime) * 100) / 100;
        // console.table(durations)
        log_1.stopProgress();
        watchMode_1.reloadAll();
        log_1.log(`
Generating took ${log_1.yellow(Math.floor(seconds * 100) / 100)} seconds for ${log_1.yellow(numberOfRoutes)} pages:
  That is ${log_1.yellow(routesProSecond)} pages per second,
  or ${log_1.yellow(Math.ceil(singleTime))} milliseconds for each page.
  ${durations.Traverse
            ? `
  Finding routes in the angular app took ${logSeconds(durations.Traverse)}`
            : ''}
  Pulling in route-data took ${logSeconds(durations.Discovery)}
  Rendering the pages took ${logSeconds(durations.Render)}

${cli_options_1.watch
            ? `The server is available on "${log_1.yellow(`http${cli_options_1.ssl ? 's' : ''}://${config_1.scullyConfig.hostName}:${config_1.scullyConfig.staticPort}/`)}"
${log_1.yellow('------------------------------------------------------------')}
Press ${log_1.green('r')} for re-run Scully, or ${log_1.green('q')} for close the servers.
${log_1.yellow('------------------------------------------------------------')}`
            : ''}
`);
        if (cli_options_1.stats) {
            const scullyStatsFilePath = path_1.join(config_1.scullyConfig.homeFolder, 'scullyStats.json');
            const pluginTimings = totalPluginTimes(durations);
            const scullyStats = {
                numberOfRoutes,
                generatingTime: Math.floor(seconds * 100) / 100,
                routesPerSecond: routesProSecond,
                findingRoutesAngular: durations.Traverse ? durations.Traverse / 1000 : '',
                routeDiscovery: durations.Discovery / 1000,
                renderingPages: durations.Render / 1000,
                pluginTimings,
            };
            Object.entries(pluginTimings).forEach(([name, duration]) => log_1.log(`${name.padEnd(40, ' ')} - ${(Math.floor(duration * 100) / 100).toString().padStart(10, ' ')}`));
            fs_1.writeFileSync(scullyStatsFilePath, JSON.stringify(scullyStats, undefined, 4));
        }
    });
};
function measurePerformance(resolve) {
    return (list, observer) => {
        // get timings and round to 1/100 of a milliseconds.
        const durations = Object.fromEntries(list.getEntries().map((entry) => [entry.name, Math.floor(entry.duration * 100) / 100]));
        perf_hooks_1.performance.clearMarks();
        observer.disconnect();
        performanceIds_1.performanceIds.clear();
        resolve(durations);
    };
}
function totalPluginTimes(durations) {
    return Object.entries(durations)
        .sort((a, b) => (a[0] < b[0] ? -1 : 1))
        .reduce((t, [name, dur]) => {
        if (name.startsWith('plugin-')) {
            const prop = name.slice(7).split('-')[0];
            if (!t[prop]) {
                t[prop] = +dur;
            }
            else {
                t[prop] += dur;
            }
        }
        return t;
    }, {});
}
function logSeconds(milliSeconds) {
    if (milliSeconds < 1000) {
        return log_1.yellow(Math.floor(milliSeconds)) + ' milliseconds';
    }
    return log_1.yellow(Math.floor(milliSeconds / 10) / 100) + ' seconds';
}
//# sourceMappingURL=startup.js.map