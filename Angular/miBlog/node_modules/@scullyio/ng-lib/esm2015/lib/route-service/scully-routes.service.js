/**
 * @fileoverview added by tsickle
 * Generated from: lib/route-service/scully-routes.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { of, ReplaySubject, merge } from 'rxjs';
import { catchError, map, shareReplay, switchMap, filter, } from 'rxjs/operators';
import { fetchHttp } from '../utils/fetchHttp';
import { Router, NavigationEnd } from '@angular/router';
import { basePathOnly } from '../utils/basePathOnly';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
/**
 * @record
 */
export function ScullyRoute() { }
if (false) {
    /** @type {?} */
    ScullyRoute.prototype.route;
    /** @type {?|undefined} */
    ScullyRoute.prototype.title;
    /** @type {?|undefined} */
    ScullyRoute.prototype.slugs;
    /** @type {?|undefined} */
    ScullyRoute.prototype.published;
    /** @type {?|undefined} */
    ScullyRoute.prototype.slug;
    /** @type {?|undefined} */
    ScullyRoute.prototype.sourceFile;
    /** @type {?|undefined} */
    ScullyRoute.prototype.lang;
    /* Skipping unhandled member: [prop: string]: any;*/
}
export class ScullyRoutesService {
    /**
     * @param {?} router
     */
    constructor(router) {
        this.router = router;
        this.refresh = new ReplaySubject(1);
        /**
         * An observable with all routes, published and unpublished alike
         */
        this.allRoutes$ = this.refresh.pipe(switchMap((/**
         * @return {?}
         */
        () => fetchHttp('assets/scully-routes.json'))), catchError((/**
         * @return {?}
         */
        () => {
            console.warn('Scully routes file not found, are you running the Scully generated version of your site?');
            return of((/** @type {?} */ ([])));
        })), 
        /** filter out all non-array results */
        filter((/**
         * @param {?} routes
         * @return {?}
         */
        (routes) => Array.isArray(routes))), map(this.cleanDups), shareReplay({ refCount: false, bufferSize: 1 }));
        /**
         * An observable with available routes (all published routes)
         */
        this.available$ = this.allRoutes$.pipe(map((/**
         * @param {?} list
         * @return {?}
         */
        (list) => list.filter((/**
         * @param {?} r
         * @return {?}
         */
        (r) => r.hasOwnProperty('published') ? r.published !== false : true)))), shareReplay({ refCount: false, bufferSize: 1 }));
        /**
         * an observable with all unpublished routes
         */
        this.unPublished$ = this.allRoutes$.pipe(map((/**
         * @param {?} list
         * @return {?}
         */
        (list) => list.filter((/**
         * @param {?} r
         * @return {?}
         */
        (r) => r.hasOwnProperty('published') ? r.published === false : false)))), shareReplay({ refCount: false, bufferSize: 1 }));
        /**
         * An observable with the top-level off all published routes.
         * (in an urls it would be `http://www.sample.org/__thisPart__/subroutes`)
         */
        this.topLevel$ = this.available$.pipe(map((/**
         * @param {?} routes
         * @return {?}
         */
        (routes) => routes.filter((/**
         * @param {?} r
         * @return {?}
         */
        (r) => !r.route.slice(1).includes('/'))))), shareReplay({ refCount: false, bufferSize: 1 }));
        /** kick off first cycle */
        this.reload();
    }
    /**
     * returns an observable that returns the route information for the
     * route currently selected. subscribes to route-events to update when needed
     * @return {?}
     */
    getCurrent() {
        if (!location) {
            /** probably not in a browser, no current location available */
            return of();
        }
        /** fire off at start, and when navigation is done. */
        return merge(of(new NavigationEnd(0, '', '')), this.router.events).pipe(filter((/**
         * @param {?} e
         * @return {?}
         */
        (e) => e instanceof NavigationEnd)), switchMap((/**
         * @return {?}
         */
        () => this.available$)), map((/**
         * @param {?} list
         * @return {?}
         */
        (list) => {
            /** @type {?} */
            const curLocation = basePathOnly(encodeURI(location.pathname).trim());
            return list.find((/**
             * @param {?} r
             * @return {?}
             */
            (r) => curLocation === basePathOnly(r.route.trim()) ||
                (r.slugs &&
                    Array.isArray(r.slugs) &&
                    r.slugs.find((/**
                     * @param {?} slug
                     * @return {?}
                     */
                    (slug) => curLocation.endsWith(basePathOnly(slug.trim())))))));
        })));
    }
    /**
     * internal, as routes can have multiple slugs, and so occur multiple times
     * this util function collapses all slugs back into 1 route.
     * @private
     * @param {?} routes
     * @return {?}
     */
    cleanDups(routes) {
        /** @type {?} */
        const m = new Map();
        /** check for duplicates by comparing all, include route in comparison if its the only thing, or the only thing with only the tile  */
        routes.forEach((/**
         * @param {?} r
         * @return {?}
         */
        (r) => m.set(JSON.stringify(Object.assign(Object.assign({}, r), { route: hasOtherprops(r) ? '' : r.route })), r)));
        return [...m.values()];
    }
    /**
     * an utility that will force a reload of the `scully-routes.json` file
     * @return {?}
     */
    reload() {
        this.refresh.next();
    }
}
ScullyRoutesService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
ScullyRoutesService.ctorParameters = () => [
    { type: Router }
];
/** @nocollapse */ ScullyRoutesService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ScullyRoutesService_Factory() { return new ScullyRoutesService(i0.ɵɵinject(i1.Router)); }, token: ScullyRoutesService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    ScullyRoutesService.prototype.refresh;
    /**
     * An observable with all routes, published and unpublished alike
     * @type {?}
     */
    ScullyRoutesService.prototype.allRoutes$;
    /**
     * An observable with available routes (all published routes)
     * @type {?}
     */
    ScullyRoutesService.prototype.available$;
    /**
     * an observable with all unpublished routes
     * @type {?}
     */
    ScullyRoutesService.prototype.unPublished$;
    /**
     * An observable with the top-level off all published routes.
     * (in an urls it would be `http://www.sample.org/__thisPart__/subroutes`)
     * @type {?}
     */
    ScullyRoutesService.prototype.topLevel$;
    /**
     * @type {?}
     * @private
     */
    ScullyRoutesService.prototype.router;
}
/**
 * @param {?} obj
 * @return {?}
 */
function hasOtherprops(obj) {
    /** @type {?} */
    const keys = Object.keys(obj);
    if (keys.length === 1 && keys.includes('route')) {
        return false;
    }
    if (keys.length === 2 && keys.includes('route') && keys.includes('title')) {
        return false;
    }
    return true;
}
//# sourceMappingURL=scully-routes.service.js.map