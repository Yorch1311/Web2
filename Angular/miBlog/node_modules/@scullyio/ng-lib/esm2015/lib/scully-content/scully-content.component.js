/**
 * @fileoverview added by tsickle
 * Generated from: lib/scully-content/scully-content.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { __awaiter } from "tslib";
import { Location } from '@angular/common';
import { ChangeDetectionStrategy, Component, ElementRef, Inject, isDevMode, ViewEncapsulation, } from '@angular/core';
import { NavigationEnd, Router } from '@angular/router';
import { filter, take, tap } from 'rxjs/operators';
import { ScullyDefaultSettings, SCULLY_LIB_CONFIG } from '../config/scully-config';
import { ScullyRoutesService } from '../route-service/scully-routes.service';
import { basePathOnly } from '../utils/basePathOnly';
import { fetchHttp } from '../utils/fetchHttp';
import { findComments } from '../utils/findComments';
/**
 * @record
 */
function ScullyContent() { }
if (false) {
    /** @type {?} */
    ScullyContent.prototype.html;
    /** @type {?} */
    ScullyContent.prototype.cssId;
}
/**
 * this is needed, because otherwise the CLI borks while building
 * @type {?}
 */
const scullyBegin = '<!--scullyContent-begin-->';
/** @type {?} */
const scullyEnd = '<!--scullyContent-end-->';
/**
 * use the module's closure to keep a system-wide check for the last handled URL.
 * @type {?}
 */
let lastHandled;
export class ScullyContentComponent {
    /**
     * @param {?} elmRef
     * @param {?} srs
     * @param {?} router
     * @param {?} location
     * @param {?} conf
     */
    constructor(elmRef, srs, router, location, conf) {
        this.elmRef = elmRef;
        this.srs = srs;
        this.router = router;
        this.location = location;
        this.conf = conf;
        this.baseUrl = this.conf.useTransferState || ScullyDefaultSettings.useTransferState;
        this.elm = (/** @type {?} */ (this.elmRef.nativeElement));
        /**
         * pull in all  available routes into an eager promise
         */
        this.routes = this.srs.allRoutes$.pipe(take(1)).toPromise();
        /**
         * monitor the router, so we can update while navigating in the same 'page' see #311
         */
        this.routeUpdates$ = this.router.events.pipe(filter((/**
         * @param {?} ev
         * @return {?}
         */
        (ev) => ev instanceof NavigationEnd)), 
        /** don't replace if we are already there */
        filter((/**
         * @param {?} ev
         * @return {?}
         */
        (ev) => lastHandled && !lastHandled.endsWith(ev.urlAfterRedirects))), tap((/**
         * @param {?} r
         * @return {?}
         */
        (r) => this.replaceContent())));
        this.routeSub = this.routeUpdates$.subscribe();
        /** do this from constructor, so it runs ASAP */
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.elm) {
            /** this will only fire in a browser environment */
            this.handlePage();
        }
    }
    /**
     * Loads the static content from scully into the view
     * Will fetch the content from sibling links with xmlHTTPrequest
     * @private
     * @return {?}
     */
    handlePage() {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const curPage = basePathOnly(location.href);
            if (lastHandled === curPage) {
                /**
                 * Due to the fix we needed for #311
                 * it might happen that this routine is called
                 * twice for the same page.
                 * this code will make sure the second one is ignored.
                 */
                return;
            }
            lastHandled = curPage;
            /** @type {?} */
            const template = document.createElement('template');
            /** @type {?} */
            const currentCssId = this.getCSSId(this.elm);
            if (window.scullyContent) {
                /**
                 * upgrade existing static content
                 * @type {?}
                 */
                const htmlString = window.scullyContent.html;
                if (currentCssId !== window.scullyContent.cssId) {
                    /** replace the angular cssId */
                    template.innerHTML = htmlString.split(window.scullyContent.cssId).join(currentCssId);
                }
                else {
                    template.innerHTML = htmlString;
                }
            }
            else {
                /**
                 *   NOTE
                 * when updateting the texts for the errors, make sure you leave the
                 *  `id="___scully-parsing-error___"`
                 * in there. That way users can detect rendering errors in their CI
                 * on a reliable way.
                 */
                yield fetchHttp(curPage + '/index.html', 'text')
                    .catch((/**
                 * @param {?} e
                 * @return {?}
                 */
                (e) => {
                    if (isDevMode()) {
                        /**
                         * in devmode (usually in `ng serve`) check the scully server for the content too
                         * @type {?}
                         */
                        const uri = new URL(location.href);
                        /** @type {?} */
                        const url = `${this.conf.baseURIForScullyContent}/${basePathOnly(uri.pathname)}/index.html`;
                        return fetchHttp(url, 'text');
                    }
                    else {
                        return Promise.reject(e);
                    }
                }))
                    .then((/**
                 * @param {?} html
                 * @return {?}
                 */
                (html) => {
                    try {
                        /** @type {?} */
                        const htmlString = html.split(scullyBegin)[1].split(scullyEnd)[0];
                        if (htmlString.includes('_ngcontent')) {
                            /**
                             * update the angular cssId
                             * @type {?}
                             */
                            const atr = '_ngcontent' + htmlString.split('_ngcontent')[1].split('=')[0];
                            template.innerHTML = htmlString.split(atr).join(currentCssId);
                        }
                        else {
                            template.innerHTML = htmlString;
                        }
                    }
                    catch (e) {
                        template.innerHTML = `<h2 id="___scully-parsing-error___">Sorry, could not parse static page content</h2>
            <p>This might happen if you are not using the static generated pages.</p>`;
                    }
                }))
                    .catch((/**
                 * @param {?} e
                 * @return {?}
                 */
                (e) => {
                    template.innerHTML = '<h2 id="___scully-parsing-error___">Sorry, could not load static page content</h2>';
                    console.error('problem during loading static scully content', e);
                }));
            }
            /**
             * insert the whole thing just before the `<scully-content>` element
             * @type {?}
             */
            const parent = this.elm.parentElement || document.body;
            /** @type {?} */
            const begin = document.createComment('scullyContent-begin');
            /** @type {?} */
            const end = document.createComment('scullyContent-end');
            parent.insertBefore(begin, this.elm);
            parent.insertBefore(template.content, this.elm);
            parent.insertBefore(end, this.elm);
            /** upgrade all hrefs to simulated routelinks (in next microtask) */
            setTimeout((/**
             * @return {?}
             */
            () => document.querySelectorAll('[href]').forEach(this.upgradeToRoutelink.bind(this))), 10);
            // document.querySelectorAll('[href]').forEach(this.upgradeToRoutelink.bind(this));
        });
    }
    /**
     * upgrade a **href** attributes to links that respect the Angular router
     * and don't do a full page reload. Only works on links that are found in the
     * Scully route config file.
     * @param {?} elm the element containing the **hrefs**
     * @return {?}
     */
    upgradeToRoutelink(elm) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!['A', 'BUTTON'].includes(elm.tagName)) {
                return;
            }
            /** @type {?} */
            const hash = elm.dataset.hash;
            if (hash) {
                elm.setAttribute('href', '#' + hash);
                elm.setAttribute('onclick', '');
                elm.onclick = (/**
                 * @param {?} ev
                 * @return {?}
                 */
                (ev) => {
                    ev.preventDefault();
                    /** @type {?} */
                    const destination = document.getElementById(hash);
                    if (destination) {
                        /** @type {?} */
                        const url = new URL(window.location.href);
                        url.hash = hash;
                        history.replaceState('', '', url.toString());
                        destination.scrollIntoView();
                    }
                });
                return;
            }
            /** @type {?} */
            const routes = yield this.routes;
            /** @type {?} */
            const href = elm.getAttribute('href');
            /** @type {?} */
            const lnk = basePathOnly(href.toLowerCase());
            /** @type {?} */
            const route = routes.find((/**
             * @param {?} r
             * @return {?}
             */
            (r) => basePathOnly(r.route.toLowerCase()) === lnk));
            /** only upgrade routes known by scully. */
            if (lnk && route && !lnk.startsWith('#')) {
                elm.onclick = (/**
                 * @param {?} ev
                 * @return {?}
                 */
                (ev) => __awaiter(this, void 0, void 0, function* () {
                    /** @type {?} */
                    const splitRoute = route.route.split(`/`);
                    /** @type {?} */
                    const curSplit = location.pathname.split('/');
                    // loose last "part" of route
                    curSplit.pop();
                    ev.preventDefault();
                    /** @type {?} */
                    const routed = yield this.router.navigate(splitRoute).catch((/**
                     * @param {?} e
                     * @return {?}
                     */
                    (e) => {
                        console.error('routing error', e);
                        return false;
                    }));
                    if (!routed) {
                        return;
                    }
                    /** check for the same route with different "data", and NOT a 1 level higher (length), and is not a fragment of th same page */
                    if (curSplit.every((/**
                     * @param {?} part
                     * @param {?} i
                     * @return {?}
                     */
                    (part, i) => splitRoute[i] === part)) && splitRoute.length !== curSplit.length + 1) {
                        setTimeout((/**
                         * @return {?}
                         */
                        () => this.replaceContent()), 10); // a small delay, so we are sure the angular parts in the page are settled enough
                    }
                }));
            }
        });
    }
    /**
     * @private
     * @return {?}
     */
    replaceContent() {
        /**
         * as Angular doesn't destroy the component if we stay on the same page,
         * we have to manually delete old content. Also we need to kick of loading
         * the new content. handlePage() takes care of that.
         */
        /** delete the content, as it is now out of date! */
        window.scullyContent = undefined;
        /** @type {?} */
        const parent = this.elm.parentElement;
        /** @type {?} */
        let cur = (/** @type {?} */ (findComments(parent, 'scullyContent-begin')[0]));
        while (cur && cur !== this.elm) {
            /** @type {?} */
            const next = cur.nextSibling;
            parent.removeChild(cur);
            cur = next;
        }
        this.handlePage();
    }
    /**
     * @param {?} elm
     * @return {?}
     */
    getCSSId(elm) {
        return elm.getAttributeNames().find((/**
         * @param {?} a
         * @return {?}
         */
        (a) => a.startsWith('_ngcontent'))) || '';
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.routeSub.unsubscribe();
        /** reset the lastused */
        lastHandled = '//';
    }
}
ScullyContentComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line: component-selector
                selector: 'scully-content',
                template: '<ng-content></ng-content>',
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                preserveWhitespaces: true,
                styles: [`
      :host {
        display: none;
      }
      scully-content {
        display: none;
      }
    `]
            }] }
];
/** @nocollapse */
ScullyContentComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ScullyRoutesService },
    { type: Router },
    { type: Location },
    { type: undefined, decorators: [{ type: Inject, args: [SCULLY_LIB_CONFIG,] }] }
];
if (false) {
    /** @type {?} */
    ScullyContentComponent.prototype.baseUrl;
    /** @type {?} */
    ScullyContentComponent.prototype.elm;
    /**
     * pull in all  available routes into an eager promise
     * @type {?}
     */
    ScullyContentComponent.prototype.routes;
    /**
     * monitor the router, so we can update while navigating in the same 'page' see #311
     * @type {?}
     */
    ScullyContentComponent.prototype.routeUpdates$;
    /** @type {?} */
    ScullyContentComponent.prototype.routeSub;
    /**
     * @type {?}
     * @private
     */
    ScullyContentComponent.prototype.elmRef;
    /**
     * @type {?}
     * @private
     */
    ScullyContentComponent.prototype.srs;
    /**
     * @type {?}
     * @private
     */
    ScullyContentComponent.prototype.router;
    /**
     * @type {?}
     * @private
     */
    ScullyContentComponent.prototype.location;
    /**
     * @type {?}
     * @private
     */
    ScullyContentComponent.prototype.conf;
}
//# sourceMappingURL=scully-content.component.js.map