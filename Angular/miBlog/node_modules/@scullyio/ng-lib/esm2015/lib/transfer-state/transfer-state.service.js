/**
 * @fileoverview added by tsickle
 * Generated from: lib/transfer-state/transfer-state.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { __awaiter } from "tslib";
import { DOCUMENT } from '@angular/common';
import { Inject, Injectable } from '@angular/core';
import { NavigationEnd, NavigationStart, Router } from '@angular/router';
import { BehaviorSubject, NEVER, of } from 'rxjs';
import { catchError, filter, first, map, pluck, shareReplay, switchMap, take, takeWhile, tap } from 'rxjs/operators';
import { basePathOnly } from '../utils/basePathOnly';
import { fetchHttp } from '../utils/fetchHttp';
import { isScullyGenerated, isScullyRunning } from '../utils/isScully';
import { mergePaths } from '../utils/merge-paths';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "@angular/router";
/** @type {?} */
const SCULLY_SCRIPT_ID = `ScullyIO-transfer-state`;
/** @type {?} */
const SCULLY_STATE_START = `/** ___SCULLY_STATE_START___ */`;
/** @type {?} */
const SCULLY_STATE_END = `/** ___SCULLY_STATE_END___ */`;
/** @type {?} */
const initialStateDone = '__done__with__Initial__navigation__';
/**
 * @record
 */
function State() { }
// Adding this dynamic comment to suppress ngc error around Document as a DI token.
// https://github.com/angular/angular/issues/20351#issuecomment-344009887
/**
 * \@dynamic
 */
export class TransferStateService {
    /**
     * @param {?} document
     * @param {?} router
     */
    constructor(document, router) {
        this.document = document;
        this.router = router;
        /**
         * parse from index, or load from data.json, according to scullConfig setting
         */
        this.inlineOnly = false;
        /**
         * set the currentBase to something that it can never be
         */
        this.currentBaseUrl = '//';
        /**
         * subject to fire off incoming states
         */
        this.stateBS = new BehaviorSubject({});
        this.state$ = this.stateBS.pipe(filter((/**
         * @param {?} state
         * @return {?}
         */
        (state) => state !== undefined)));
        // emit the next url when routing is complete
        this.nextUrl = this.router.events.pipe(filter((/**
         * @param {?} e
         * @return {?}
         */
        (e) => e instanceof NavigationStart)), switchMap((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (basePathOnly(this.initialUrl) === basePathOnly(e.url)) {
                /** don't kick off on initial load to prevent flicker */
                this.initialUrl = initialStateDone;
                return NEVER;
            }
            return of(e);
        })), 
        /** reset the state, so new components will never get stale data */
        tap((/**
         * @return {?}
         */
        () => this.stateBS.next(undefined))), 
        /** prevent emitting before navigation to _this_ URL is done. */
        switchMap((/**
         * @param {?} e
         * @return {?}
         */
        (e) => this.router.events.pipe(filter((/**
         * @param {?} ev
         * @return {?}
         */
        (ev) => ev instanceof NavigationEnd && ev.url === e.url)), first()))), map((/**
         * @param {?} ev
         * @return {?}
         */
        (ev) => basePathOnly(ev.urlAfterRedirects || ev.url))), shareReplay(1));
    }
    /**
     * @return {?}
     */
    startMonitoring() {
        if (window && window['ScullyIO-injected'] && window['ScullyIO-injected'].inlineStateOnly) {
            this.inlineOnly = true;
        }
        this.setupEnvForTransferState();
        this.setupStartNavMonitoring();
    }
    /**
     * @private
     * @return {?}
     */
    setupEnvForTransferState() {
        if (isScullyRunning()) {
            this.injectScript();
            // In Scully puppeteer
            /** @type {?} */
            const exposed = window['ScullyIO-exposed'] || {};
            if (exposed.transferState) {
                this.stateBS.next(exposed.transferState);
                this.saveState(exposed.transferState);
            }
        }
        else if (isScullyGenerated()) {
            // On the client AFTER scully rendered it
            this.initialUrl = window.location.pathname || '__no_NO_no__';
            this.initialUrl = this.initialUrl !== '/' && this.initialUrl.endsWith('/') ? this.initialUrl.slice(0, -1) : this.initialUrl;
            /** set the initial state */
            this.stateBS.next((window && window[SCULLY_SCRIPT_ID]) || {});
        }
    }
    /**
     * @private
     * @return {?}
     */
    injectScript() {
        this.script = this.document.createElement('script');
        this.script.setAttribute('id', SCULLY_SCRIPT_ID);
        /** @type {?} */
        let last = document.body.lastChild;
        while (last.previousSibling.nodeName === 'SCRIPT') {
            last = (/** @type {?} */ (last.previousSibling));
        }
        document.body.insertBefore(this.script, last);
    }
    /**
     * Getstate will return an observable that containes the data.
     * It does so right after the navigation for the page has finished.
     * please note, this works SYNC on initial route, preventing a flash of content.
     * @template T
     * @param {?} name The name of the state to
     * @return {?}
     */
    getState(name) {
        /** start of the fetch for the current active route. */
        this.fetchTransferState();
        return this.state$.pipe(pluck(name)
        // tap((data) => console.log('tss', data))
        );
    }
    /**
     * Read the current state, and see if it has an value for the name.
     * (note the value it containes still can be undefined!)
     * @param {?} name
     * @return {?}
     */
    stateHasKey(name) {
        return this.stateBS.value && this.stateBS.value.hasOwnProperty(name);
    }
    /**
     * Read the current state, and see if it has an value for the name.
     * ys also if there is actually an value in the state.
     * @param {?} name
     * @return {?}
     */
    stateKeyHasValue(name) {
        return this.stateBS.value && this.stateBS.value.hasOwnProperty(name) && this.stateBS.value[name] != null;
    }
    /**
     * SetState will update the script in the generated page with data added.
     * @template T
     * @param {?} name
     * @param {?} val
     * @return {?}
     */
    setState(name, val) {
        /** @type {?} */
        const newState = Object.assign(Object.assign({}, this.stateBS.value), { [name]: val });
        this.stateBS.next(newState);
        this.saveState(newState);
    }
    /**
     * @private
     * @param {?} newState
     * @return {?}
     */
    saveState(newState) {
        if (isScullyRunning()) {
            this.script.textContent = `{window['${SCULLY_SCRIPT_ID}']=_u(\`${SCULLY_STATE_START}${escapeHtml(JSON.stringify(newState))}${SCULLY_STATE_END}\`);function _u(t){t=t.split('${SCULLY_STATE_START}')[1].split('${SCULLY_STATE_END}')[0];const u={'_~b~': "${'`'}",'_~q~': "'",'_~o~': '$','_~s~': '/','_~l~': '<','_~g~': '>'};return JSON.parse(t.replace(/_~d~/g,'\\\\"').replace(/_~[^]~/g, (s) => u[s]).replace(/\\n/g,'\\\\n').replace(/\\t/g,'\\\\t').replace(/\\r/g,'\\\\r'));}}`;
        }
    }
    /**
     * starts monitoring the router, and keep the url from the last completed navigation handy.
     * @private
     * @return {?}
     */
    setupStartNavMonitoring() {
        if (!isScullyGenerated()) {
            return;
        }
        /** start monitoring the routes */
        this.nextUrl.subscribe();
    }
    /**
     * Wraps an observable into scully's transfer state. If data for the provided `name` is
     * available in the state, it gets returned. Otherwise, the `originalState` observable will
     * be returned.
     *
     * On subsequent calls, the data in the state will always be returned. The `originalState` will
     * be returned only once.
     *
     * This is a convenience method which does not require you to use `getState`/`setState` manually.
     *
     * @template T
     * @param {?} name state key
     * @param {?} originalState an observable which yields the desired data
     * @return {?}
     */
    useScullyTransferState(name, originalState) {
        if (isScullyGenerated()) {
            return this.getState(name);
        }
        return originalState.pipe(tap((/**
         * @param {?} state
         * @return {?}
         */
        (state) => this.setState(name, state))));
    }
    /**
     * @private
     * @return {?}
     */
    fetchTransferState() {
        return __awaiter(this, void 0, void 0, function* () {
            /**
             * helper to read the part before the first slash (ignores leading slash)
             * @type {?}
             */
            const base = (/**
             * @param {?} url
             * @return {?}
             */
            (url) => url.split('/').filter((/**
             * @param {?} part
             * @return {?}
             */
            (part) => part.trim() !== ''))[0]);
            /** put this in the next event cycle so the correct route can be read */
            yield new Promise((/**
             * @param {?} r
             * @return {?}
             */
            (r) => setTimeout(r, 0)));
            /**
             * get the current url
             * @type {?}
             */
            const currentUrl = yield this.nextUrl.pipe(take(1)).toPromise();
            /** @type {?} */
            const baseUrl = base(currentUrl);
            if (this.currentBaseUrl === baseUrl) {
                /** already monitoring, don't tho a thing */
                return;
            }
            /** keep the baseUrl for later reference */
            this.currentBaseUrl = baseUrl;
            this.nextUrl
                .pipe(
            /** keep updating till we move to another route */
            takeWhile((/**
             * @param {?} url
             * @return {?}
             */
            (url) => base(url) === this.currentBaseUrl)), 
            // Get the next route's data from the the index or data file
            switchMap((/**
             * @param {?} url
             * @return {?}
             */
            (url) => (this.inlineOnly ? this.readFromIndex(url) : this.readFromJson(url)))), catchError((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                // TODO: come up with better error text.
                /** the developer needs to know, but its not fatal, so just return an empty state */
                console.warn('Error while loading of parsing Scully state:', e);
                return of({});
            })), tap((/**
             * @param {?} newState
             * @return {?}
             */
            (newState) => {
                /** and activate the state in the components. on any error it will be empty */
                this.stateBS.next(newState);
            })))
                .subscribe({
                /**
                 * when completes (different URL)
                 */
                complete: (/**
                 * @return {?}
                 */
                () => {
                    /** reset the currentBaseUrl */
                    this.currentBaseUrl = '//';
                }),
            });
        });
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    readFromJson(url) {
        return fetchHttp(dropPreSlash(mergePaths(url, '/data.json')));
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    readFromIndex(url) {
        return fetchHttp(dropPreSlash(mergePaths(url, '/index.html')), 'text').then((/**
         * @param {?} html
         * @return {?}
         */
        (html) => {
            /** @type {?} */
            const newStateStr = html.split(SCULLY_STATE_START)[1].split(SCULLY_STATE_END)[0];
            return JSON.parse(unescapeHtml(newStateStr));
        }));
    }
}
TransferStateService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
TransferStateService.ctorParameters = () => [
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Router }
];
/** @nocollapse */ TransferStateService.ɵprov = i0.ɵɵdefineInjectable({ factory: function TransferStateService_Factory() { return new TransferStateService(i0.ɵɵinject(i1.DOCUMENT), i0.ɵɵinject(i2.Router)); }, token: TransferStateService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    TransferStateService.prototype.script;
    /**
     * parse from index, or load from data.json, according to scullConfig setting
     * @type {?}
     * @private
     */
    TransferStateService.prototype.inlineOnly;
    /**
     * @type {?}
     * @private
     */
    TransferStateService.prototype.initialUrl;
    /**
     * set the currentBase to something that it can never be
     * @type {?}
     * @private
     */
    TransferStateService.prototype.currentBaseUrl;
    /**
     * subject to fire off incoming states
     * @type {?}
     * @private
     */
    TransferStateService.prototype.stateBS;
    /**
     * @type {?}
     * @private
     */
    TransferStateService.prototype.state$;
    /**
     * @type {?}
     * @private
     */
    TransferStateService.prototype.nextUrl;
    /**
     * @type {?}
     * @private
     */
    TransferStateService.prototype.document;
    /**
     * @type {?}
     * @private
     */
    TransferStateService.prototype.router;
}
/**
 * @param {?} string
 * @return {?}
 */
function dropPreSlash(string) {
    return string.startsWith('/') ? string.slice(1) : string;
}
/**
 * we need to escape our HTML to prevent XXS,
 * It needs to be custom, because the content can already contain html-escaped sequences
 *
 * @param {?} text
 * @return {?}
 */
export function escapeHtml(text) {
    /** @type {?} */
    const escapedText = {
        "'": '_~q~',
        $: '_~o~',
        '`': '_~b~',
        '/': '_~s~',
        '<': '_~l~',
        '>': '_~g~',
    };
    return (text
        /** escape the json */
        .replace(/[\$`'<>\/]/g, (/**
     * @param {?} s
     * @return {?}
     */
    (s) => escapedText[s]))
        /** replace escaped double-quotes with single */
        .replace(/\\\"/g, `_~d~`));
}
/**
 * Unescape our custom escaped texts
 * @param {?} text
 * @return {?}
 */
export function unescapeHtml(text) {
    /** @type {?} */
    const unescapedText = {
        '_~q~': "'",
        '_~b~': '`',
        '_~o~': '$',
        '_~s~': '/',
        '_~l~': '<',
        '_~g~': '>',
    };
    return (text
        /** put back escaped double quotes to make valid json again */
        .replace(/_~d~/g, `\\"`)
        /** replace the custom escapes */
        .replace(/_~[^]~/g, (/**
     * @param {?} s
     * @return {?}
     */
    (s) => unescapedText[s]))
        /** restore newlines+cr */
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r'));
}
//# sourceMappingURL=transfer-state.service.js.map