/**
 * @fileoverview added by tsickle
 * Generated from: lib/idleMonitor/idle-monitor.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { __awaiter } from "tslib";
import { Inject, Injectable, NgZone } from '@angular/core';
import { NavigationEnd, Router } from '@angular/router';
import { BehaviorSubject } from 'rxjs';
import { filter, pluck, take, tap } from 'rxjs/operators';
import { SCULLY_LIB_CONFIG, ScullyDefaultSettings } from '../config/scully-config';
import { TransferStateService } from '../transfer-state/transfer-state.service';
import { isScullyRunning } from '../utils/isScully';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
import * as i2 from "../config/scully-config";
import * as i3 from "../transfer-state/transfer-state.service";
/**
 * @record
 */
function LocalState() { }
if (false) {
    /** @type {?} */
    LocalState.prototype.idle;
    /** @type {?} */
    LocalState.prototype.timeOut;
}
// if (window) {
//   window.addEventListener('AngularReady', ev => {
//     console.log('appReady fired', ev);
//   });
// }
export class IdleMonitorService {
    /**
     * @param {?} zone
     * @param {?} router
     * @param {?} conf
     * @param {?} tss
     */
    constructor(zone, router, conf, tss) {
        this.zone = zone;
        this.router = router;
        /**
         * store the 'landing' url so we can skip it in idle-check.
         */
        this.initialUrl = dropEndingSlash(window && window.location && window.location.pathname) || '';
        this.imState = new BehaviorSubject({
            idle: false,
            timeOut: 5 * 1000,
        });
        this.idle$ = this.imState.pipe(pluck('idle'));
        this.initApp = new Event('AngularInitialized', {
            bubbles: true,
            cancelable: false,
        });
        this.appReady = new Event('AngularReady', {
            bubbles: true,
            cancelable: false,
        });
        this.appTimeout = new Event('AngularTimeout', {
            bubbles: true,
            cancelable: false,
        });
        /** provide the default for missing conf paramter */
        this.scullyLibConfig = Object.assign({}, ScullyDefaultSettings, conf);
        /** @type {?} */
        const exposed = window['ScullyIO-exposed'] || {};
        /** @type {?} */
        const manualIdle = !!exposed.manualIdle;
        if (!this.scullyLibConfig.manualIdle && window && (this.scullyLibConfig.alwaysMonitor || isScullyRunning())) {
            window.dispatchEvent(this.initApp);
            this.router.events
                .pipe(filter((/**
             * @param {?} ev
             * @return {?}
             */
            (ev) => ev instanceof NavigationEnd && ev.urlAfterRedirects !== undefined)), 
            /** don't check the page that has this setting. event is only importand on page load */
            filter((/**
             * @param {?} ev
             * @return {?}
             */
            (ev) => (manualIdle ? ev.urlAfterRedirects !== this.initialUrl : true))), tap((/**
             * @return {?}
             */
            () => this.zoneIdleCheck())))
                .subscribe();
        }
        if (this.scullyLibConfig.manualIdle) {
            /** we still need the init event. */
            window.dispatchEvent(this.initApp);
        }
        if (this.scullyLibConfig.useTransferState) {
            /** don't start monitoring if people don't use the transferState */
            tss.startMonitoring();
        }
    }
    /**
     * @return {?}
     */
    fireManualMyAppReadyEvent() {
        return __awaiter(this, void 0, void 0, function* () {
            return window.dispatchEvent(this.appReady);
        });
    }
    /**
     * @return {?}
     */
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.idle$.pipe(take(1)).toPromise();
        });
    }
    /**
     * @private
     * @return {?}
     */
    zoneIdleCheck() {
        return __awaiter(this, void 0, void 0, function* () {
            if (Zone === undefined) {
                return this.simpleTimeout();
            }
            /** @type {?} */
            const taskTrackingZone = Zone.current.get('TaskTrackingZone');
            if (taskTrackingZone === undefined) {
                return this.simpleTimeout();
            }
            if (this.imState.value.idle) {
                yield this.setState('idle', false);
            }
            /** run the actual check for 'idle' outsides zone, otherwise it will never come to an end. */
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                /** @type {?} */
                let tCancel;
                /** @type {?} */
                let count = 0;
                /** @type {?} */
                const startTime = Date.now();
                /** @type {?} */
                const monitor = (/**
                 * @return {?}
                 */
                () => {
                    clearTimeout(tCancel);
                    // console.table(taskTrackingZone.macroTasks);
                    if (Date.now() - startTime > 30 * 1000) {
                        /** bail out after 30 seconds. */
                        window.dispatchEvent(this.appTimeout);
                        return;
                    }
                    if ((taskTrackingZone.macroTasks.length > 0 &&
                        taskTrackingZone.macroTasks.find((/**
                         * @param {?} z
                         * @return {?}
                         */
                        (z) => z.source.includes('XMLHttpRequest'))) !==
                            undefined) ||
                        count < 1 // make sure it runs at least once!
                    ) {
                        tCancel = setTimeout((/**
                         * @return {?}
                         */
                        () => {
                            count += 1;
                            monitor();
                        }), 50);
                        return;
                    }
                    this.zone.run((/**
                     * @return {?}
                     */
                    () => {
                        /** run this inside the zone, and give the app 250Ms to wrap up, before scraping starts */
                        setTimeout((/**
                         * @return {?}
                         */
                        () => {
                            window.dispatchEvent(this.appReady);
                            this.setState('idle', true);
                        }), 250);
                    }));
                });
                monitor();
            }));
        });
    }
    /**
     * @private
     * @return {?}
     */
    simpleTimeout() {
        return __awaiter(this, void 0, void 0, function* () {
            /** zone not available, use a timeout instead. */
            console.warn('Scully is using timeouts, add the needed polyfills instead!');
            yield new Promise((/**
             * @param {?} r
             * @return {?}
             */
            (r) => setTimeout(r, this.imState.value.timeOut)));
            window.dispatchEvent(this.appReady);
        });
    }
    /**
     * @param {?} milliseconds
     * @return {?}
     */
    setPupeteerTimeoutValue(milliseconds) {
        this.imState.next(Object.assign(Object.assign({}, this.imState.value), { timeOut: milliseconds }));
    }
    /**
     * @private
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    setState(key, value) {
        this.imState.next(Object.assign(Object.assign({}, this.imState.value), { [key]: value }));
    }
}
IdleMonitorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
IdleMonitorService.ctorParameters = () => [
    { type: NgZone },
    { type: Router },
    { type: undefined, decorators: [{ type: Inject, args: [SCULLY_LIB_CONFIG,] }] },
    { type: TransferStateService }
];
/** @nocollapse */ IdleMonitorService.ɵprov = i0.ɵɵdefineInjectable({ factory: function IdleMonitorService_Factory() { return new IdleMonitorService(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.Router), i0.ɵɵinject(i2.SCULLY_LIB_CONFIG), i0.ɵɵinject(i3.TransferStateService)); }, token: IdleMonitorService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    IdleMonitorService.prototype.scullyLibConfig;
    /**
     * store the 'landing' url so we can skip it in idle-check.
     * @type {?}
     * @private
     */
    IdleMonitorService.prototype.initialUrl;
    /**
     * @type {?}
     * @private
     */
    IdleMonitorService.prototype.imState;
    /** @type {?} */
    IdleMonitorService.prototype.idle$;
    /**
     * @type {?}
     * @private
     */
    IdleMonitorService.prototype.initApp;
    /**
     * @type {?}
     * @private
     */
    IdleMonitorService.prototype.appReady;
    /**
     * @type {?}
     * @private
     */
    IdleMonitorService.prototype.appTimeout;
    /**
     * @type {?}
     * @private
     */
    IdleMonitorService.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    IdleMonitorService.prototype.router;
}
/**
 * @param {?} str
 * @return {?}
 */
export function dropEndingSlash(str) {
    return str.endsWith('/') ? str.slice(0, -1) : str;
}
//# sourceMappingURL=idle-monitor.service.js.map