import { Router } from '@angular/router';
import { Observable } from 'rxjs';
declare global {
    interface Window {
        'ScullyIO-injected': {
            inlineStateOnly?: boolean;
            [key: string]: any;
        };
    }
}
/** @dynamic */
export declare class TransferStateService {
    private document;
    private router;
    private script;
    /** parse from index, or load from data.json, according to scullConfig setting */
    private inlineOnly;
    private initialUrl;
    /** set the currentBase to something that it can never be */
    private currentBaseUrl;
    /** subject to fire off incoming states */
    private stateBS;
    private state$;
    private nextUrl;
    constructor(document: Document, router: Router);
    startMonitoring(): void;
    private setupEnvForTransferState;
    private injectScript;
    /**
     * Getstate will return an observable that containes the data.
     * It does so right after the navigation for the page has finished.
     * please note, this works SYNC on initial route, preventing a flash of content.
     * @param name The name of the state to
     */
    getState<T>(name: string): Observable<T>;
    /**
     * Read the current state, and see if it has an value for the name.
     * (note the value it containes still can be undefined!)
     */
    stateHasKey(name: string): boolean;
    /**
     * Read the current state, and see if it has an value for the name.
     * ys also if there is actually an value in the state.
     */
    stateKeyHasValue(name: string): boolean;
    /**
     * SetState will update the script in the generated page with data added.
     * @param name
     * @param val
     */
    setState<T>(name: string, val: T): void;
    private saveState;
    /**
     * starts monitoring the router, and keep the url from the last completed navigation handy.
     */
    private setupStartNavMonitoring;
    /**
     * Wraps an observable into scully's transfer state. If data for the provided `name` is
     * available in the state, it gets returned. Otherwise, the `originalState` observable will
     * be returned.
     *
     * On subsequent calls, the data in the state will always be returned. The `originalState` will
     * be returned only once.
     *
     * This is a convenience method which does not require you to use `getState`/`setState` manually.
     *
     * @param name state key
     * @param originalState an observable which yields the desired data
     */
    useScullyTransferState<T>(name: string, originalState: Observable<T>): Observable<T>;
    private fetchTransferState;
    private readFromJson;
    private readFromIndex;
}
/**
 * we need to escape our HTML to prevent XXS,
 * It needs to be custom, because the content can already contain html-escaped sequences
 **/
export declare function escapeHtml(text: string): string;
/**
 * Unescape our custom escaped texts
 * @param text
 */
export declare function unescapeHtml(text: string): string;
