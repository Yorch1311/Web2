{"version":3,"file":"transfer-state.service.d.ts","sources":["transfer-state.service.d.ts"],"names":[],"mappings":"AAAA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { Router } from '@angular/router';\nimport { Observable } from 'rxjs';\ndeclare global {\n    interface Window {\n        'ScullyIO-injected': {\n            inlineStateOnly?: boolean;\n            [key: string]: any;\n        };\n    }\n}\n/** @dynamic */\nexport declare class TransferStateService {\n    private document;\n    private router;\n    private script;\n    /** parse from index, or load from data.json, according to scullConfig setting */\n    private inlineOnly;\n    private initialUrl;\n    /** set the currentBase to something that it can never be */\n    private currentBaseUrl;\n    /** subject to fire off incoming states */\n    private stateBS;\n    private state$;\n    private nextUrl;\n    constructor(document: Document, router: Router);\n    startMonitoring(): void;\n    private setupEnvForTransferState;\n    private injectScript;\n    /**\n     * Getstate will return an observable that containes the data.\n     * It does so right after the navigation for the page has finished.\n     * please note, this works SYNC on initial route, preventing a flash of content.\n     * @param name The name of the state to\n     */\n    getState<T>(name: string): Observable<T>;\n    /**\n     * Read the current state, and see if it has an value for the name.\n     * (note the value it containes still can be undefined!)\n     */\n    stateHasKey(name: string): boolean;\n    /**\n     * Read the current state, and see if it has an value for the name.\n     * ys also if there is actually an value in the state.\n     */\n    stateKeyHasValue(name: string): boolean;\n    /**\n     * SetState will update the script in the generated page with data added.\n     * @param name\n     * @param val\n     */\n    setState<T>(name: string, val: T): void;\n    private saveState;\n    /**\n     * starts monitoring the router, and keep the url from the last completed navigation handy.\n     */\n    private setupStartNavMonitoring;\n    /**\n     * Wraps an observable into scully's transfer state. If data for the provided `name` is\n     * available in the state, it gets returned. Otherwise, the `originalState` observable will\n     * be returned.\n     *\n     * On subsequent calls, the data in the state will always be returned. The `originalState` will\n     * be returned only once.\n     *\n     * This is a convenience method which does not require you to use `getState`/`setState` manually.\n     *\n     * @param name state key\n     * @param originalState an observable which yields the desired data\n     */\n    useScullyTransferState<T>(name: string, originalState: Observable<T>): Observable<T>;\n    private fetchTransferState;\n    private readFromJson;\n    private readFromIndex;\n}\n/**\n * we need to escape our HTML to prevent XXS,\n * It needs to be custom, because the content can already contain html-escaped sequences\n **/\nexport declare function escapeHtml(text: string): string;\n/**\n * Unescape our custom escaped texts\n * @param text\n */\nexport declare function unescapeHtml(text: string): string;\n"]}