(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/router'), require('rxjs'), require('rxjs/operators'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('@scullyio/ng-lib', ['exports', '@angular/core', '@angular/router', 'rxjs', 'rxjs/operators', '@angular/common'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.scullyio = global.scullyio || {}, global.scullyio['ng-lib'] = {}), global.ng.core, global.ng.router, global.rxjs, global.rxjs.operators, global.ng.common));
}(this, (function (exports, i0, i1, rxjs, operators, i1$1) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/config/scully-config.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function ScullyLibConfig() { }
    if (false) {
        /** @type {?|undefined} */
        ScullyLibConfig.prototype.useTransferState;
        /** @type {?|undefined} */
        ScullyLibConfig.prototype.alwaysMonitor;
        /** @type {?|undefined} */
        ScullyLibConfig.prototype.manualIdle;
        /** @type {?|undefined} */
        ScullyLibConfig.prototype.baseURIForScullyContent;
    }
    /** @type {?} */
    var ScullyDefaultSettings = {
        useTransferState: true,
        alwaysMonitor: false,
        manualIdle: false,
        baseURIForScullyContent: 'http://localhost:1668',
    };
    /** @type {?} */
    var SCULLY_LIB_CONFIG = new i0.InjectionToken('scullyLibConfig', {
        factory: ( /**
         * @return {?}
         */function () { return ScullyDefaultSettings; }),
    });

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/utils/basePathOnly.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Take a string, preferably resembling an URL, take out the search params, the anchors, and the ending slash
     * \@param str
     * @type {?}
     */
    var basePathOnly = ( /**
     * @param {?} str
     * @return {?}
     */function (str) {
        if (str.includes('#')) {
            str = str.split('#')[0];
        }
        if (str.includes('?')) {
            str = str.split('?')[0];
        }
        /** @type {?} */
        var cleanedUpVersion = str.endsWith('/') ? str.slice(0, -1) : str;
        return cleanedUpVersion;
    });

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/utils/fetchHttp.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @template T
     * @param {?} url
     * @param {?=} responseType
     * @return {?}
     */
    function fetchHttp(url, responseType) {
        if (responseType === void 0) { responseType = 'json'; }
        return new Promise(( /**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */function (resolve, reject) {
            /** @type {?} */
            var xhr = new XMLHttpRequest();
            xhr.responseType = responseType;
            xhr.addEventListener('load', ( /**
             * @param {?} ev
             * @return {?}
             */function (/**
             * @param {?} ev
             * @return {?}
             */ ev) {
                if (xhr.status !== 200) {
                    return reject(xhr);
                }
                resolve(xhr.response);
            }));
            xhr.addEventListener('error', ( /**
             * @param {...?} err
             * @return {?}
             */function () {
                var err = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    err[_i] = arguments[_i];
                }
                return reject(err);
            }));
            xhr.open('get', url, true);
            xhr.send();
        }));
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/utils/isScully.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // tslint:disable: no-string-literal
    /** @type {?} */
    var isScullyRunning = ( /**
     * @return {?}
     */function () { return window && window['ScullyIO'] === 'running'; });
    /** @type {?} */
    var isScullyGenerated = ( /**
     * @return {?}
     */function () { return window && window['ScullyIO'] === 'generated'; });

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/utils/merge-paths.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} base
     * @param {?} path
     * @return {?}
     */
    function mergePaths(base, path) {
        if (base.endsWith('/') && path.startsWith('/')) {
            return "" + base + path.substr(1);
        }
        if (!base.endsWith('/') && !path.startsWith('/')) {
            return base + "/" + path;
        }
        return "" + base + path;
    }

    /** @type {?} */
    var SCULLY_SCRIPT_ID = "ScullyIO-transfer-state";
    /** @type {?} */
    var SCULLY_STATE_START = "/** ___SCULLY_STATE_START___ */";
    /** @type {?} */
    var SCULLY_STATE_END = "/** ___SCULLY_STATE_END___ */";
    /** @type {?} */
    var initialStateDone = '__done__with__Initial__navigation__';
    /**
     * @record
     */
    function State() { }
    // Adding this dynamic comment to suppress ngc error around Document as a DI token.
    // https://github.com/angular/angular/issues/20351#issuecomment-344009887
    /**
     * \@dynamic
     */
    var TransferStateService = /** @class */ (function () {
        /**
         * @param {?} document
         * @param {?} router
         */
        function TransferStateService(document, router) {
            var _this = this;
            this.document = document;
            this.router = router;
            /**
             * parse from index, or load from data.json, according to scullConfig setting
             */
            this.inlineOnly = false;
            /**
             * set the currentBase to something that it can never be
             */
            this.currentBaseUrl = '//';
            /**
             * subject to fire off incoming states
             */
            this.stateBS = new rxjs.BehaviorSubject({});
            this.state$ = this.stateBS.pipe(operators.filter(( /**
             * @param {?} state
             * @return {?}
             */function (state) { return state !== undefined; })));
            // emit the next url when routing is complete
            this.nextUrl = this.router.events.pipe(operators.filter(( /**
             * @param {?} e
             * @return {?}
             */function (e) { return e instanceof i1.NavigationStart; })), operators.switchMap(( /**
             * @param {?} e
             * @return {?}
             */function (e) {
                if (basePathOnly(_this.initialUrl) === basePathOnly(e.url)) {
                    /** don't kick off on initial load to prevent flicker */
                    _this.initialUrl = initialStateDone;
                    return rxjs.NEVER;
                }
                return rxjs.of(e);
            })), 
            /** reset the state, so new components will never get stale data */
            operators.tap(( /**
             * @return {?}
             */function () { return _this.stateBS.next(undefined); })), 
            /** prevent emitting before navigation to _this_ URL is done. */
            operators.switchMap(( /**
             * @param {?} e
             * @return {?}
             */function (e) { return _this.router.events.pipe(operators.filter(( /**
             * @param {?} ev
             * @return {?}
             */function (ev) { return ev instanceof i1.NavigationEnd && ev.url === e.url; })), operators.first()); })), operators.map(( /**
             * @param {?} ev
             * @return {?}
             */function (ev) { return basePathOnly(ev.urlAfterRedirects || ev.url); })), operators.shareReplay(1));
        }
        /**
         * @return {?}
         */
        TransferStateService.prototype.startMonitoring = function () {
            if (window && window['ScullyIO-injected'] && window['ScullyIO-injected'].inlineStateOnly) {
                this.inlineOnly = true;
            }
            this.setupEnvForTransferState();
            this.setupStartNavMonitoring();
        };
        /**
         * @private
         * @return {?}
         */
        TransferStateService.prototype.setupEnvForTransferState = function () {
            if (isScullyRunning()) {
                this.injectScript();
                // In Scully puppeteer
                /** @type {?} */
                var exposed = window['ScullyIO-exposed'] || {};
                if (exposed.transferState) {
                    this.stateBS.next(exposed.transferState);
                    this.saveState(exposed.transferState);
                }
            }
            else if (isScullyGenerated()) {
                // On the client AFTER scully rendered it
                this.initialUrl = window.location.pathname || '__no_NO_no__';
                this.initialUrl = this.initialUrl !== '/' && this.initialUrl.endsWith('/') ? this.initialUrl.slice(0, -1) : this.initialUrl;
                /** set the initial state */
                this.stateBS.next((window && window[SCULLY_SCRIPT_ID]) || {});
            }
        };
        /**
         * @private
         * @return {?}
         */
        TransferStateService.prototype.injectScript = function () {
            this.script = this.document.createElement('script');
            this.script.setAttribute('id', SCULLY_SCRIPT_ID);
            /** @type {?} */
            var last = document.body.lastChild;
            while (last.previousSibling.nodeName === 'SCRIPT') {
                last = ( /** @type {?} */(last.previousSibling));
            }
            document.body.insertBefore(this.script, last);
        };
        /**
         * Getstate will return an observable that containes the data.
         * It does so right after the navigation for the page has finished.
         * please note, this works SYNC on initial route, preventing a flash of content.
         * @template T
         * @param {?} name The name of the state to
         * @return {?}
         */
        TransferStateService.prototype.getState = function (name) {
            /** start of the fetch for the current active route. */
            this.fetchTransferState();
            return this.state$.pipe(operators.pluck(name)
            // tap((data) => console.log('tss', data))
            );
        };
        /**
         * Read the current state, and see if it has an value for the name.
         * (note the value it containes still can be undefined!)
         * @param {?} name
         * @return {?}
         */
        TransferStateService.prototype.stateHasKey = function (name) {
            return this.stateBS.value && this.stateBS.value.hasOwnProperty(name);
        };
        /**
         * Read the current state, and see if it has an value for the name.
         * ys also if there is actually an value in the state.
         * @param {?} name
         * @return {?}
         */
        TransferStateService.prototype.stateKeyHasValue = function (name) {
            return this.stateBS.value && this.stateBS.value.hasOwnProperty(name) && this.stateBS.value[name] != null;
        };
        /**
         * SetState will update the script in the generated page with data added.
         * @template T
         * @param {?} name
         * @param {?} val
         * @return {?}
         */
        TransferStateService.prototype.setState = function (name, val) {
            var _a;
            /** @type {?} */
            var newState = Object.assign(Object.assign({}, this.stateBS.value), (_a = {}, _a[name] = val, _a));
            this.stateBS.next(newState);
            this.saveState(newState);
        };
        /**
         * @private
         * @param {?} newState
         * @return {?}
         */
        TransferStateService.prototype.saveState = function (newState) {
            if (isScullyRunning()) {
                this.script.textContent = "{window['" + SCULLY_SCRIPT_ID + "']=_u(`" + SCULLY_STATE_START + escapeHtml(JSON.stringify(newState)) + SCULLY_STATE_END + "`);function _u(t){t=t.split('" + SCULLY_STATE_START + "')[1].split('" + SCULLY_STATE_END + "')[0];const u={'_~b~': \"" + '`' + "\",'_~q~': \"'\",'_~o~': '$','_~s~': '/','_~l~': '<','_~g~': '>'};return JSON.parse(t.replace(/_~d~/g,'\\\\\"').replace(/_~[^]~/g, (s) => u[s]).replace(/\\n/g,'\\\\n').replace(/\\t/g,'\\\\t').replace(/\\r/g,'\\\\r'));}}";
            }
        };
        /**
         * starts monitoring the router, and keep the url from the last completed navigation handy.
         * @private
         * @return {?}
         */
        TransferStateService.prototype.setupStartNavMonitoring = function () {
            if (!isScullyGenerated()) {
                return;
            }
            /** start monitoring the routes */
            this.nextUrl.subscribe();
        };
        /**
         * Wraps an observable into scully's transfer state. If data for the provided `name` is
         * available in the state, it gets returned. Otherwise, the `originalState` observable will
         * be returned.
         *
         * On subsequent calls, the data in the state will always be returned. The `originalState` will
         * be returned only once.
         *
         * This is a convenience method which does not require you to use `getState`/`setState` manually.
         *
         * @template T
         * @param {?} name state key
         * @param {?} originalState an observable which yields the desired data
         * @return {?}
         */
        TransferStateService.prototype.useScullyTransferState = function (name, originalState) {
            var _this = this;
            if (isScullyGenerated()) {
                return this.getState(name);
            }
            return originalState.pipe(operators.tap(( /**
             * @param {?} state
             * @return {?}
             */function (state) { return _this.setState(name, state); })));
        };
        /**
         * @private
         * @return {?}
         */
        TransferStateService.prototype.fetchTransferState = function () {
            return __awaiter(this, void 0, void 0, function () {
                var base, currentUrl, baseUrl;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            base = ( /**
                             * @param {?} url
                             * @return {?}
                             */function (url) { return url.split('/').filter(( /**
                             * @param {?} part
                             * @return {?}
                             */function (part) { return part.trim() !== ''; }))[0]; });
                            /** put this in the next event cycle so the correct route can be read */
                            return [4 /*yield*/, new Promise(( /**
                                 * @param {?} r
                                 * @return {?}
                                 */function (r) { return setTimeout(r, 0); }))];
                        case 1:
                            /** put this in the next event cycle so the correct route can be read */
                            _a.sent();
                            return [4 /*yield*/, this.nextUrl.pipe(operators.take(1)).toPromise()];
                        case 2:
                            currentUrl = _a.sent();
                            baseUrl = base(currentUrl);
                            if (this.currentBaseUrl === baseUrl) {
                                /** already monitoring, don't tho a thing */
                                return [2 /*return*/];
                            }
                            /** keep the baseUrl for later reference */
                            this.currentBaseUrl = baseUrl;
                            this.nextUrl
                                .pipe(
                            /** keep updating till we move to another route */
                            operators.takeWhile(( /**
                             * @param {?} url
                             * @return {?}
                             */function (url) { return base(url) === _this.currentBaseUrl; })), 
                            // Get the next route's data from the the index or data file
                            operators.switchMap(( /**
                             * @param {?} url
                             * @return {?}
                             */function (url) { return (_this.inlineOnly ? _this.readFromIndex(url) : _this.readFromJson(url)); })), operators.catchError(( /**
                             * @param {?} e
                             * @return {?}
                             */function (e) {
                                // TODO: come up with better error text.
                                /** the developer needs to know, but its not fatal, so just return an empty state */
                                console.warn('Error while loading of parsing Scully state:', e);
                                return rxjs.of({});
                            })), operators.tap(( /**
                             * @param {?} newState
                             * @return {?}
                             */function (newState) {
                                /** and activate the state in the components. on any error it will be empty */
                                _this.stateBS.next(newState);
                            })))
                                .subscribe({
                                /**
                                 * when completes (different URL)
                                 */
                                complete: ( /**
                                 * @return {?}
                                 */function () {
                                    /** reset the currentBaseUrl */
                                    _this.currentBaseUrl = '//';
                                }),
                            });
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * @private
         * @param {?} url
         * @return {?}
         */
        TransferStateService.prototype.readFromJson = function (url) {
            return fetchHttp(dropPreSlash(mergePaths(url, '/data.json')));
        };
        /**
         * @private
         * @param {?} url
         * @return {?}
         */
        TransferStateService.prototype.readFromIndex = function (url) {
            return fetchHttp(dropPreSlash(mergePaths(url, '/index.html')), 'text').then(( /**
             * @param {?} html
             * @return {?}
             */function (html) {
                /** @type {?} */
                var newStateStr = html.split(SCULLY_STATE_START)[1].split(SCULLY_STATE_END)[0];
                return JSON.parse(unescapeHtml(newStateStr));
            }));
        };
        return TransferStateService;
    }());
    TransferStateService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    /** @nocollapse */
    TransferStateService.ctorParameters = function () { return [
        { type: Document, decorators: [{ type: i0.Inject, args: [i1$1.DOCUMENT,] }] },
        { type: i1.Router }
    ]; };
    /** @nocollapse */ TransferStateService.ɵprov = i0.ɵɵdefineInjectable({ factory: function TransferStateService_Factory() { return new TransferStateService(i0.ɵɵinject(i1$1.DOCUMENT), i0.ɵɵinject(i1.Router)); }, token: TransferStateService, providedIn: "root" });
    if (false) {
        /**
         * @type {?}
         * @private
         */
        TransferStateService.prototype.script;
        /**
         * parse from index, or load from data.json, according to scullConfig setting
         * @type {?}
         * @private
         */
        TransferStateService.prototype.inlineOnly;
        /**
         * @type {?}
         * @private
         */
        TransferStateService.prototype.initialUrl;
        /**
         * set the currentBase to something that it can never be
         * @type {?}
         * @private
         */
        TransferStateService.prototype.currentBaseUrl;
        /**
         * subject to fire off incoming states
         * @type {?}
         * @private
         */
        TransferStateService.prototype.stateBS;
        /**
         * @type {?}
         * @private
         */
        TransferStateService.prototype.state$;
        /**
         * @type {?}
         * @private
         */
        TransferStateService.prototype.nextUrl;
        /**
         * @type {?}
         * @private
         */
        TransferStateService.prototype.document;
        /**
         * @type {?}
         * @private
         */
        TransferStateService.prototype.router;
    }
    /**
     * @param {?} string
     * @return {?}
     */
    function dropPreSlash(string) {
        return string.startsWith('/') ? string.slice(1) : string;
    }
    /**
     * we need to escape our HTML to prevent XXS,
     * It needs to be custom, because the content can already contain html-escaped sequences
     *
     * @param {?} text
     * @return {?}
     */
    function escapeHtml(text) {
        /** @type {?} */
        var escapedText = {
            "'": '_~q~',
            $: '_~o~',
            '`': '_~b~',
            '/': '_~s~',
            '<': '_~l~',
            '>': '_~g~',
        };
        return (text
            /** escape the json */
            .replace(/[\$`'<>\/]/g, ( /**
     * @param {?} s
     * @return {?}
     */function (s) { return escapedText[s]; }))
            /** replace escaped double-quotes with single */
            .replace(/\\\"/g, "_~d~"));
    }
    /**
     * Unescape our custom escaped texts
     * @param {?} text
     * @return {?}
     */
    function unescapeHtml(text) {
        /** @type {?} */
        var unescapedText = {
            '_~q~': "'",
            '_~b~': '`',
            '_~o~': '$',
            '_~s~': '/',
            '_~l~': '<',
            '_~g~': '>',
        };
        return (text
            /** put back escaped double quotes to make valid json again */
            .replace(/_~d~/g, "\\\"")
            /** replace the custom escapes */
            .replace(/_~[^]~/g, ( /**
     * @param {?} s
     * @return {?}
     */function (s) { return unescapedText[s]; }))
            /** restore newlines+cr */
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r'));
    }

    /**
     * @record
     */
    function LocalState() { }
    if (false) {
        /** @type {?} */
        LocalState.prototype.idle;
        /** @type {?} */
        LocalState.prototype.timeOut;
    }
    // if (window) {
    //   window.addEventListener('AngularReady', ev => {
    //     console.log('appReady fired', ev);
    //   });
    // }
    var IdleMonitorService = /** @class */ (function () {
        /**
         * @param {?} zone
         * @param {?} router
         * @param {?} conf
         * @param {?} tss
         */
        function IdleMonitorService(zone, router, conf, tss) {
            var _this = this;
            this.zone = zone;
            this.router = router;
            /**
             * store the 'landing' url so we can skip it in idle-check.
             */
            this.initialUrl = dropEndingSlash(window && window.location && window.location.pathname) || '';
            this.imState = new rxjs.BehaviorSubject({
                idle: false,
                timeOut: 5 * 1000,
            });
            this.idle$ = this.imState.pipe(operators.pluck('idle'));
            this.initApp = new Event('AngularInitialized', {
                bubbles: true,
                cancelable: false,
            });
            this.appReady = new Event('AngularReady', {
                bubbles: true,
                cancelable: false,
            });
            this.appTimeout = new Event('AngularTimeout', {
                bubbles: true,
                cancelable: false,
            });
            /** provide the default for missing conf paramter */
            this.scullyLibConfig = Object.assign({}, ScullyDefaultSettings, conf);
            /** @type {?} */
            var exposed = window['ScullyIO-exposed'] || {};
            /** @type {?} */
            var manualIdle = !!exposed.manualIdle;
            if (!this.scullyLibConfig.manualIdle && window && (this.scullyLibConfig.alwaysMonitor || isScullyRunning())) {
                window.dispatchEvent(this.initApp);
                this.router.events
                    .pipe(operators.filter(( /**
             * @param {?} ev
             * @return {?}
             */function (ev) { return ev instanceof i1.NavigationEnd && ev.urlAfterRedirects !== undefined; })), 
                /** don't check the page that has this setting. event is only importand on page load */
                operators.filter(( /**
                 * @param {?} ev
                 * @return {?}
                 */function (ev) { return (manualIdle ? ev.urlAfterRedirects !== _this.initialUrl : true); })), operators.tap(( /**
                 * @return {?}
                 */function () { return _this.zoneIdleCheck(); })))
                    .subscribe();
            }
            if (this.scullyLibConfig.manualIdle) {
                /** we still need the init event. */
                window.dispatchEvent(this.initApp);
            }
            if (this.scullyLibConfig.useTransferState) {
                /** don't start monitoring if people don't use the transferState */
                tss.startMonitoring();
            }
        }
        /**
         * @return {?}
         */
        IdleMonitorService.prototype.fireManualMyAppReadyEvent = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, window.dispatchEvent(this.appReady)];
                });
            });
        };
        /**
         * @return {?}
         */
        IdleMonitorService.prototype.init = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, this.idle$.pipe(operators.take(1)).toPromise()];
                });
            });
        };
        /**
         * @private
         * @return {?}
         */
        IdleMonitorService.prototype.zoneIdleCheck = function () {
            return __awaiter(this, void 0, void 0, function () {
                var taskTrackingZone;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (Zone === undefined) {
                                return [2 /*return*/, this.simpleTimeout()];
                            }
                            taskTrackingZone = Zone.current.get('TaskTrackingZone');
                            if (taskTrackingZone === undefined) {
                                return [2 /*return*/, this.simpleTimeout()];
                            }
                            if (!this.imState.value.idle) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.setState('idle', false)];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            /** run the actual check for 'idle' outsides zone, otherwise it will never come to an end. */
                            this.zone.runOutsideAngular(( /**
                             * @return {?}
                             */function () {
                                /** @type {?} */
                                var tCancel;
                                /** @type {?} */
                                var count = 0;
                                /** @type {?} */
                                var startTime = Date.now();
                                /** @type {?} */
                                var monitor = ( /**
                                 * @return {?}
                                 */function () {
                                    clearTimeout(tCancel);
                                    // console.table(taskTrackingZone.macroTasks);
                                    if (Date.now() - startTime > 30 * 1000) {
                                        /** bail out after 30 seconds. */
                                        window.dispatchEvent(_this.appTimeout);
                                        return;
                                    }
                                    if ((taskTrackingZone.macroTasks.length > 0 &&
                                        taskTrackingZone.macroTasks.find(( /**
                                         * @param {?} z
                                         * @return {?}
                                         */function (z) { return z.source.includes('XMLHttpRequest'); })) !==
                                            undefined) ||
                                        count < 1 // make sure it runs at least once!
                                    ) {
                                        tCancel = setTimeout(( /**
                                         * @return {?}
                                         */function () {
                                            count += 1;
                                            monitor();
                                        }), 50);
                                        return;
                                    }
                                    _this.zone.run(( /**
                                     * @return {?}
                                     */function () {
                                        /** run this inside the zone, and give the app 250Ms to wrap up, before scraping starts */
                                        setTimeout(( /**
                                         * @return {?}
                                         */function () {
                                            window.dispatchEvent(_this.appReady);
                                            _this.setState('idle', true);
                                        }), 250);
                                    }));
                                });
                                monitor();
                            }));
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * @private
         * @return {?}
         */
        IdleMonitorService.prototype.simpleTimeout = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            /** zone not available, use a timeout instead. */
                            console.warn('Scully is using timeouts, add the needed polyfills instead!');
                            return [4 /*yield*/, new Promise(( /**
                                 * @param {?} r
                                 * @return {?}
                                 */function (r) { return setTimeout(r, _this.imState.value.timeOut); }))];
                        case 1:
                            _a.sent();
                            window.dispatchEvent(this.appReady);
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * @param {?} milliseconds
         * @return {?}
         */
        IdleMonitorService.prototype.setPupeteerTimeoutValue = function (milliseconds) {
            this.imState.next(Object.assign(Object.assign({}, this.imState.value), { timeOut: milliseconds }));
        };
        /**
         * @private
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        IdleMonitorService.prototype.setState = function (key, value) {
            var _a;
            this.imState.next(Object.assign(Object.assign({}, this.imState.value), (_a = {}, _a[key] = value, _a)));
        };
        return IdleMonitorService;
    }());
    IdleMonitorService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    /** @nocollapse */
    IdleMonitorService.ctorParameters = function () { return [
        { type: i0.NgZone },
        { type: i1.Router },
        { type: undefined, decorators: [{ type: i0.Inject, args: [SCULLY_LIB_CONFIG,] }] },
        { type: TransferStateService }
    ]; };
    /** @nocollapse */ IdleMonitorService.ɵprov = i0.ɵɵdefineInjectable({ factory: function IdleMonitorService_Factory() { return new IdleMonitorService(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.Router), i0.ɵɵinject(SCULLY_LIB_CONFIG), i0.ɵɵinject(TransferStateService)); }, token: IdleMonitorService, providedIn: "root" });
    if (false) {
        /**
         * @type {?}
         * @private
         */
        IdleMonitorService.prototype.scullyLibConfig;
        /**
         * store the 'landing' url so we can skip it in idle-check.
         * @type {?}
         * @private
         */
        IdleMonitorService.prototype.initialUrl;
        /**
         * @type {?}
         * @private
         */
        IdleMonitorService.prototype.imState;
        /** @type {?} */
        IdleMonitorService.prototype.idle$;
        /**
         * @type {?}
         * @private
         */
        IdleMonitorService.prototype.initApp;
        /**
         * @type {?}
         * @private
         */
        IdleMonitorService.prototype.appReady;
        /**
         * @type {?}
         * @private
         */
        IdleMonitorService.prototype.appTimeout;
        /**
         * @type {?}
         * @private
         */
        IdleMonitorService.prototype.zone;
        /**
         * @type {?}
         * @private
         */
        IdleMonitorService.prototype.router;
    }
    /**
     * @param {?} str
     * @return {?}
     */
    function dropEndingSlash(str) {
        return str.endsWith('/') ? str.slice(0, -1) : str;
    }

    /**
     * @record
     */
    function ScullyRoute() { }
    if (false) {
        /** @type {?} */
        ScullyRoute.prototype.route;
        /** @type {?|undefined} */
        ScullyRoute.prototype.title;
        /** @type {?|undefined} */
        ScullyRoute.prototype.slugs;
        /** @type {?|undefined} */
        ScullyRoute.prototype.published;
        /** @type {?|undefined} */
        ScullyRoute.prototype.slug;
        /** @type {?|undefined} */
        ScullyRoute.prototype.sourceFile;
        /** @type {?|undefined} */
        ScullyRoute.prototype.lang;
        /* Skipping unhandled member: [prop: string]: any;*/
    }
    var ScullyRoutesService = /** @class */ (function () {
        /**
         * @param {?} router
         */
        function ScullyRoutesService(router) {
            this.router = router;
            this.refresh = new rxjs.ReplaySubject(1);
            /**
             * An observable with all routes, published and unpublished alike
             */
            this.allRoutes$ = this.refresh.pipe(operators.switchMap(( /**
             * @return {?}
             */function () { return fetchHttp('assets/scully-routes.json'); })), operators.catchError(( /**
             * @return {?}
             */function () {
                console.warn('Scully routes file not found, are you running the Scully generated version of your site?');
                return rxjs.of(( /** @type {?} */([])));
            })), 
            /** filter out all non-array results */
            operators.filter(( /**
             * @param {?} routes
             * @return {?}
             */function (routes) { return Array.isArray(routes); })), operators.map(this.cleanDups), operators.shareReplay({ refCount: false, bufferSize: 1 }));
            /**
             * An observable with available routes (all published routes)
             */
            this.available$ = this.allRoutes$.pipe(operators.map(( /**
             * @param {?} list
             * @return {?}
             */function (list) { return list.filter(( /**
             * @param {?} r
             * @return {?}
             */function (r) { return r.hasOwnProperty('published') ? r.published !== false : true; })); })), operators.shareReplay({ refCount: false, bufferSize: 1 }));
            /**
             * an observable with all unpublished routes
             */
            this.unPublished$ = this.allRoutes$.pipe(operators.map(( /**
             * @param {?} list
             * @return {?}
             */function (list) { return list.filter(( /**
             * @param {?} r
             * @return {?}
             */function (r) { return r.hasOwnProperty('published') ? r.published === false : false; })); })), operators.shareReplay({ refCount: false, bufferSize: 1 }));
            /**
             * An observable with the top-level off all published routes.
             * (in an urls it would be `http://www.sample.org/__thisPart__/subroutes`)
             */
            this.topLevel$ = this.available$.pipe(operators.map(( /**
             * @param {?} routes
             * @return {?}
             */function (routes) { return routes.filter(( /**
             * @param {?} r
             * @return {?}
             */function (r) { return !r.route.slice(1).includes('/'); })); })), operators.shareReplay({ refCount: false, bufferSize: 1 }));
            /** kick off first cycle */
            this.reload();
        }
        /**
         * returns an observable that returns the route information for the
         * route currently selected. subscribes to route-events to update when needed
         * @return {?}
         */
        ScullyRoutesService.prototype.getCurrent = function () {
            var _this = this;
            if (!location) {
                /** probably not in a browser, no current location available */
                return rxjs.of();
            }
            /** fire off at start, and when navigation is done. */
            return rxjs.merge(rxjs.of(new i1.NavigationEnd(0, '', '')), this.router.events).pipe(operators.filter(( /**
             * @param {?} e
             * @return {?}
             */function (e) { return e instanceof i1.NavigationEnd; })), operators.switchMap(( /**
             * @return {?}
             */function () { return _this.available$; })), operators.map(( /**
             * @param {?} list
             * @return {?}
             */function (list) {
                /** @type {?} */
                var curLocation = basePathOnly(encodeURI(location.pathname).trim());
                return list.find(( /**
                 * @param {?} r
                 * @return {?}
                 */function (r) { return curLocation === basePathOnly(r.route.trim()) ||
                    (r.slugs &&
                        Array.isArray(r.slugs) &&
                        r.slugs.find(( /**
                         * @param {?} slug
                         * @return {?}
                         */function (slug) { return curLocation.endsWith(basePathOnly(slug.trim())); }))); }));
            })));
        };
        /**
         * internal, as routes can have multiple slugs, and so occur multiple times
         * this util function collapses all slugs back into 1 route.
         * @private
         * @param {?} routes
         * @return {?}
         */
        ScullyRoutesService.prototype.cleanDups = function (routes) {
            /** @type {?} */
            var m = new Map();
            /** check for duplicates by comparing all, include route in comparison if its the only thing, or the only thing with only the tile  */
            routes.forEach(( /**
             * @param {?} r
             * @return {?}
             */function (r) { return m.set(JSON.stringify(Object.assign(Object.assign({}, r), { route: hasOtherprops(r) ? '' : r.route })), r); }));
            return __spread(m.values());
        };
        /**
         * an utility that will force a reload of the `scully-routes.json` file
         * @return {?}
         */
        ScullyRoutesService.prototype.reload = function () {
            this.refresh.next();
        };
        return ScullyRoutesService;
    }());
    ScullyRoutesService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    /** @nocollapse */
    ScullyRoutesService.ctorParameters = function () { return [
        { type: i1.Router }
    ]; };
    /** @nocollapse */ ScullyRoutesService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ScullyRoutesService_Factory() { return new ScullyRoutesService(i0.ɵɵinject(i1.Router)); }, token: ScullyRoutesService, providedIn: "root" });
    if (false) {
        /**
         * @type {?}
         * @private
         */
        ScullyRoutesService.prototype.refresh;
        /**
         * An observable with all routes, published and unpublished alike
         * @type {?}
         */
        ScullyRoutesService.prototype.allRoutes$;
        /**
         * An observable with available routes (all published routes)
         * @type {?}
         */
        ScullyRoutesService.prototype.available$;
        /**
         * an observable with all unpublished routes
         * @type {?}
         */
        ScullyRoutesService.prototype.unPublished$;
        /**
         * An observable with the top-level off all published routes.
         * (in an urls it would be `http://www.sample.org/__thisPart__/subroutes`)
         * @type {?}
         */
        ScullyRoutesService.prototype.topLevel$;
        /**
         * @type {?}
         * @private
         */
        ScullyRoutesService.prototype.router;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    function hasOtherprops(obj) {
        /** @type {?} */
        var keys = Object.keys(obj);
        if (keys.length === 1 && keys.includes('route')) {
            return false;
        }
        if (keys.length === 2 && keys.includes('route') && keys.includes('title')) {
            return false;
        }
        return true;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/utils/findComments.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Returns an array of nodes coninting all the html comments in the element.
     * When a searchText is given this is narrowed down to only comments that contian this text
     * @param {?} rootElem Element to search nto
     * @param {?=} searchText optional string that needs to be in a HTML comment
     * @return {?}
     */
    function findComments(rootElem, searchText) {
        /** @type {?} */
        var comments = [];
        // Fourth argument, which is actually obsolete according to the DOM4 standard, seems required in IE 11
        /** @type {?} */
        var iterator = document.createNodeIterator(rootElem, NodeFilter.SHOW_COMMENT, {
            acceptNode: ( /**
             * @param {?} node
             * @return {?}
             */function (/**
             * @param {?} node
             * @return {?}
             */ node) {
                // Logic to determine whether to accept, reject or skip node
                // In this case, only accept nodes that have content
                // that is containing our searchText, by rejecting any other nodes.
                if (searchText &&
                    node.nodeValue &&
                    !node.nodeValue.includes(searchText)) {
                    return NodeFilter.FILTER_REJECT;
                }
                return NodeFilter.FILTER_ACCEPT;
            })
        }
        // , false // IE-11 support requires this parameter.
        );
        /** @type {?} */
        var curNode;
        // tslint:disable-next-line: no-conditional-assignment
        while ((curNode = iterator.nextNode())) {
            comments.push(curNode);
        }
        return comments;
    }

    /**
     * @record
     */
    function ScullyContent() { }
    if (false) {
        /** @type {?} */
        ScullyContent.prototype.html;
        /** @type {?} */
        ScullyContent.prototype.cssId;
    }
    /**
     * this is needed, because otherwise the CLI borks while building
     * @type {?}
     */
    var scullyBegin = '<!--scullyContent-begin-->';
    /** @type {?} */
    var scullyEnd = '<!--scullyContent-end-->';
    /**
     * use the module's closure to keep a system-wide check for the last handled URL.
     * @type {?}
     */
    var lastHandled;
    var ScullyContentComponent = /** @class */ (function () {
        /**
         * @param {?} elmRef
         * @param {?} srs
         * @param {?} router
         * @param {?} location
         * @param {?} conf
         */
        function ScullyContentComponent(elmRef, srs, router, location, conf) {
            var _this = this;
            this.elmRef = elmRef;
            this.srs = srs;
            this.router = router;
            this.location = location;
            this.conf = conf;
            this.baseUrl = this.conf.useTransferState || ScullyDefaultSettings.useTransferState;
            this.elm = ( /** @type {?} */(this.elmRef.nativeElement));
            /**
             * pull in all  available routes into an eager promise
             */
            this.routes = this.srs.allRoutes$.pipe(operators.take(1)).toPromise();
            /**
             * monitor the router, so we can update while navigating in the same 'page' see #311
             */
            this.routeUpdates$ = this.router.events.pipe(operators.filter(( /**
             * @param {?} ev
             * @return {?}
             */function (ev) { return ev instanceof i1.NavigationEnd; })), 
            /** don't replace if we are already there */
            operators.filter(( /**
             * @param {?} ev
             * @return {?}
             */function (ev) { return lastHandled && !lastHandled.endsWith(ev.urlAfterRedirects); })), operators.tap(( /**
             * @param {?} r
             * @return {?}
             */function (r) { return _this.replaceContent(); })));
            this.routeSub = this.routeUpdates$.subscribe();
            /** do this from constructor, so it runs ASAP */
        }
        /**
         * @return {?}
         */
        ScullyContentComponent.prototype.ngOnInit = function () {
            if (this.elm) {
                /** this will only fire in a browser environment */
                this.handlePage();
            }
        };
        /**
         * Loads the static content from scully into the view
         * Will fetch the content from sibling links with xmlHTTPrequest
         * @private
         * @return {?}
         */
        ScullyContentComponent.prototype.handlePage = function () {
            return __awaiter(this, void 0, void 0, function () {
                var curPage, template, currentCssId, htmlString, parent, begin, end;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            curPage = basePathOnly(location.href);
                            if (lastHandled === curPage) {
                                /**
                                 * Due to the fix we needed for #311
                                 * it might happen that this routine is called
                                 * twice for the same page.
                                 * this code will make sure the second one is ignored.
                                 */
                                return [2 /*return*/];
                            }
                            lastHandled = curPage;
                            template = document.createElement('template');
                            currentCssId = this.getCSSId(this.elm);
                            if (!window.scullyContent) return [3 /*break*/, 1];
                            htmlString = window.scullyContent.html;
                            if (currentCssId !== window.scullyContent.cssId) {
                                /** replace the angular cssId */
                                template.innerHTML = htmlString.split(window.scullyContent.cssId).join(currentCssId);
                            }
                            else {
                                template.innerHTML = htmlString;
                            }
                            return [3 /*break*/, 3];
                        case 1: 
                        /**
                         *   NOTE
                         * when updateting the texts for the errors, make sure you leave the
                         *  `id="___scully-parsing-error___"`
                         * in there. That way users can detect rendering errors in their CI
                         * on a reliable way.
                         */
                        return [4 /*yield*/, fetchHttp(curPage + '/index.html', 'text')
                                .catch(( /**
                         * @param {?} e
                         * @return {?}
                         */function (e) {
                                if (i0.isDevMode()) {
                                    /**
                                     * in devmode (usually in `ng serve`) check the scully server for the content too
                                     * @type {?}
                                     */
                                    var uri = new URL(location.href);
                                    /** @type {?} */
                                    var url = _this.conf.baseURIForScullyContent + "/" + basePathOnly(uri.pathname) + "/index.html";
                                    return fetchHttp(url, 'text');
                                }
                                else {
                                    return Promise.reject(e);
                                }
                            }))
                                .then(( /**
                         * @param {?} html
                         * @return {?}
                         */function (html) {
                                try {
                                    /** @type {?} */
                                    var htmlString = html.split(scullyBegin)[1].split(scullyEnd)[0];
                                    if (htmlString.includes('_ngcontent')) {
                                        /**
                                         * update the angular cssId
                                         * @type {?}
                                         */
                                        var atr = '_ngcontent' + htmlString.split('_ngcontent')[1].split('=')[0];
                                        template.innerHTML = htmlString.split(atr).join(currentCssId);
                                    }
                                    else {
                                        template.innerHTML = htmlString;
                                    }
                                }
                                catch (e) {
                                    template.innerHTML = "<h2 id=\"___scully-parsing-error___\">Sorry, could not parse static page content</h2>\n            <p>This might happen if you are not using the static generated pages.</p>";
                                }
                            }))
                                .catch(( /**
                         * @param {?} e
                         * @return {?}
                         */function (e) {
                                template.innerHTML = '<h2 id="___scully-parsing-error___">Sorry, could not load static page content</h2>';
                                console.error('problem during loading static scully content', e);
                            }))];
                        case 2:
                            /**
                             *   NOTE
                             * when updateting the texts for the errors, make sure you leave the
                             *  `id="___scully-parsing-error___"`
                             * in there. That way users can detect rendering errors in their CI
                             * on a reliable way.
                             */
                            _a.sent();
                            _a.label = 3;
                        case 3:
                            parent = this.elm.parentElement || document.body;
                            begin = document.createComment('scullyContent-begin');
                            end = document.createComment('scullyContent-end');
                            parent.insertBefore(begin, this.elm);
                            parent.insertBefore(template.content, this.elm);
                            parent.insertBefore(end, this.elm);
                            /** upgrade all hrefs to simulated routelinks (in next microtask) */
                            setTimeout(( /**
                             * @return {?}
                             */function () { return document.querySelectorAll('[href]').forEach(_this.upgradeToRoutelink.bind(_this)); }), 10);
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * upgrade a **href** attributes to links that respect the Angular router
         * and don't do a full page reload. Only works on links that are found in the
         * Scully route config file.
         * @param {?} elm the element containing the **hrefs**
         * @return {?}
         */
        ScullyContentComponent.prototype.upgradeToRoutelink = function (elm) {
            return __awaiter(this, void 0, void 0, function () {
                var hash, routes, href, lnk, route;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!['A', 'BUTTON'].includes(elm.tagName)) {
                                return [2 /*return*/];
                            }
                            hash = elm.dataset.hash;
                            if (hash) {
                                elm.setAttribute('href', '#' + hash);
                                elm.setAttribute('onclick', '');
                                elm.onclick = ( /**
                                 * @param {?} ev
                                 * @return {?}
                                 */function (ev) {
                                    ev.preventDefault();
                                    /** @type {?} */
                                    var destination = document.getElementById(hash);
                                    if (destination) {
                                        /** @type {?} */
                                        var url = new URL(window.location.href);
                                        url.hash = hash;
                                        history.replaceState('', '', url.toString());
                                        destination.scrollIntoView();
                                    }
                                });
                                return [2 /*return*/];
                            }
                            return [4 /*yield*/, this.routes];
                        case 1:
                            routes = _a.sent();
                            href = elm.getAttribute('href');
                            lnk = basePathOnly(href.toLowerCase());
                            route = routes.find(( /**
                             * @param {?} r
                             * @return {?}
                             */function (r) { return basePathOnly(r.route.toLowerCase()) === lnk; }));
                            /** only upgrade routes known by scully. */
                            if (lnk && route && !lnk.startsWith('#')) {
                                elm.onclick = ( /**
                                 * @param {?} ev
                                 * @return {?}
                                 */function (ev) { return __awaiter(_this, void 0, void 0, function () {
                                    var splitRoute, curSplit, routed;
                                    var _this = this;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                splitRoute = route.route.split("/");
                                                curSplit = location.pathname.split('/');
                                                // loose last "part" of route
                                                curSplit.pop();
                                                ev.preventDefault();
                                                return [4 /*yield*/, this.router.navigate(splitRoute).catch(( /**
                                                     * @param {?} e
                                                     * @return {?}
                                                     */function (e) {
                                                        console.error('routing error', e);
                                                        return false;
                                                    }))];
                                            case 1:
                                                routed = _a.sent();
                                                if (!routed) {
                                                    return [2 /*return*/];
                                                }
                                                /** check for the same route with different "data", and NOT a 1 level higher (length), and is not a fragment of th same page */
                                                if (curSplit.every(( /**
                                                 * @param {?} part
                                                 * @param {?} i
                                                 * @return {?}
                                                 */function (part, i) { return splitRoute[i] === part; })) && splitRoute.length !== curSplit.length + 1) {
                                                    setTimeout(( /**
                                                     * @return {?}
                                                     */function () { return _this.replaceContent(); }), 10); // a small delay, so we are sure the angular parts in the page are settled enough
                                                }
                                                return [2 /*return*/];
                                        }
                                    });
                                }); });
                            }
                            return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * @private
         * @return {?}
         */
        ScullyContentComponent.prototype.replaceContent = function () {
            /**
             * as Angular doesn't destroy the component if we stay on the same page,
             * we have to manually delete old content. Also we need to kick of loading
             * the new content. handlePage() takes care of that.
             */
            /** delete the content, as it is now out of date! */
            window.scullyContent = undefined;
            /** @type {?} */
            var parent = this.elm.parentElement;
            /** @type {?} */
            var cur = ( /** @type {?} */(findComments(parent, 'scullyContent-begin')[0]));
            while (cur && cur !== this.elm) {
                /** @type {?} */
                var next = cur.nextSibling;
                parent.removeChild(cur);
                cur = next;
            }
            this.handlePage();
        };
        /**
         * @param {?} elm
         * @return {?}
         */
        ScullyContentComponent.prototype.getCSSId = function (elm) {
            return elm.getAttributeNames().find(( /**
             * @param {?} a
             * @return {?}
             */function (a) { return a.startsWith('_ngcontent'); })) || '';
        };
        /**
         * @return {?}
         */
        ScullyContentComponent.prototype.ngOnDestroy = function () {
            this.routeSub.unsubscribe();
            /** reset the lastused */
            lastHandled = '//';
        };
        return ScullyContentComponent;
    }());
    ScullyContentComponent.decorators = [
        { type: i0.Component, args: [{
                    // tslint:disable-next-line: component-selector
                    selector: 'scully-content',
                    template: '<ng-content></ng-content>',
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    encapsulation: i0.ViewEncapsulation.None,
                    preserveWhitespaces: true,
                    styles: ["\n      :host {\n        display: none;\n      }\n      scully-content {\n        display: none;\n      }\n    "]
                }] }
    ];
    /** @nocollapse */
    ScullyContentComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: ScullyRoutesService },
        { type: i1.Router },
        { type: i1$1.Location },
        { type: undefined, decorators: [{ type: i0.Inject, args: [SCULLY_LIB_CONFIG,] }] }
    ]; };
    if (false) {
        /** @type {?} */
        ScullyContentComponent.prototype.baseUrl;
        /** @type {?} */
        ScullyContentComponent.prototype.elm;
        /**
         * pull in all  available routes into an eager promise
         * @type {?}
         */
        ScullyContentComponent.prototype.routes;
        /**
         * monitor the router, so we can update while navigating in the same 'page' see #311
         * @type {?}
         */
        ScullyContentComponent.prototype.routeUpdates$;
        /** @type {?} */
        ScullyContentComponent.prototype.routeSub;
        /**
         * @type {?}
         * @private
         */
        ScullyContentComponent.prototype.elmRef;
        /**
         * @type {?}
         * @private
         */
        ScullyContentComponent.prototype.srs;
        /**
         * @type {?}
         * @private
         */
        ScullyContentComponent.prototype.router;
        /**
         * @type {?}
         * @private
         */
        ScullyContentComponent.prototype.location;
        /**
         * @type {?}
         * @private
         */
        ScullyContentComponent.prototype.conf;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/scully-content/scully-content.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ScullyContentModule = /** @class */ (function () {
        function ScullyContentModule() {
        }
        return ScullyContentModule;
    }());
    ScullyContentModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [ScullyContentComponent],
                    exports: [ScullyContentComponent]
                },] }
    ];

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/scully-lib.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ScullyLibModule = /** @class */ (function () {
        /**
         * @param {?} idle
         */
        function ScullyLibModule(idle) {
            this.idle = idle;
        }
        /**
         * We use a little trick to get a working idle-service.
         * First, we separate out the component in a separate module to prevent a circulair injection
         * second we create a constuctor that activates the IdleMonitorService. as that is provided for 'root'
         * there will be only 1 instance in our app.
         * We don't need forRoot, as we are not configuring anything in here.
         * @param {?=} config
         * @return {?}
         */
        ScullyLibModule.forRoot = function (config) {
            if (config === void 0) { config = ScullyDefaultSettings; }
            config = Object.assign({}, ScullyDefaultSettings, config);
            return {
                ngModule: ScullyLibModule,
                providers: [{ provide: SCULLY_LIB_CONFIG, useValue: config }],
            };
        };
        return ScullyLibModule;
    }());
    ScullyLibModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [ScullyContentModule],
                    exports: [ScullyContentModule],
                },] }
    ];
    /** @nocollapse */
    ScullyLibModule.ctorParameters = function () { return [
        { type: IdleMonitorService }
    ]; };
    if (false) {
        /**
         * @type {?}
         * @private
         */
        ScullyLibModule.prototype.idle;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: scullyio-ng-lib.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    exports.IdleMonitorService = IdleMonitorService;
    exports.ScullyContentComponent = ScullyContentComponent;
    exports.ScullyContentModule = ScullyContentModule;
    exports.ScullyLibModule = ScullyLibModule;
    exports.ScullyRoutesService = ScullyRoutesService;
    exports.TransferStateService = TransferStateService;
    exports.dropEndingSlash = dropEndingSlash;
    exports.isScullyGenerated = isScullyGenerated;
    exports.isScullyRunning = isScullyRunning;
    exports.ɵb = SCULLY_LIB_CONFIG;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=scullyio-ng-lib.umd.js.map
