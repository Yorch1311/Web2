import { __awaiter } from 'tslib';
import { InjectionToken, Injectable, Inject, ɵɵdefineInjectable, ɵɵinject, NgZone, isDevMode, Component, ChangeDetectionStrategy, ViewEncapsulation, ElementRef, NgModule } from '@angular/core';
import { NavigationStart, NavigationEnd, Router } from '@angular/router';
import { BehaviorSubject, NEVER, of, ReplaySubject, merge } from 'rxjs';
import { filter, switchMap, tap, first, map, shareReplay, pluck, take, takeWhile, catchError } from 'rxjs/operators';
import { DOCUMENT, Location } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/config/scully-config.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ScullyLibConfig() { }
if (false) {
    /** @type {?|undefined} */
    ScullyLibConfig.prototype.useTransferState;
    /** @type {?|undefined} */
    ScullyLibConfig.prototype.alwaysMonitor;
    /** @type {?|undefined} */
    ScullyLibConfig.prototype.manualIdle;
    /** @type {?|undefined} */
    ScullyLibConfig.prototype.baseURIForScullyContent;
}
/** @type {?} */
const ScullyDefaultSettings = {
    useTransferState: true,
    alwaysMonitor: false,
    manualIdle: false,
    baseURIForScullyContent: 'http://localhost:1668',
};
/** @type {?} */
const SCULLY_LIB_CONFIG = new InjectionToken('scullyLibConfig', {
    factory: (/**
     * @return {?}
     */
    () => ScullyDefaultSettings),
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/basePathOnly.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Take a string, preferably resembling an URL, take out the search params, the anchors, and the ending slash
 * \@param str
 * @type {?}
 */
const basePathOnly = (/**
 * @param {?} str
 * @return {?}
 */
(str) => {
    if (str.includes('#')) {
        str = str.split('#')[0];
    }
    if (str.includes('?')) {
        str = str.split('?')[0];
    }
    /** @type {?} */
    const cleanedUpVersion = str.endsWith('/') ? str.slice(0, -1) : str;
    return cleanedUpVersion;
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/fetchHttp.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} url
 * @param {?=} responseType
 * @return {?}
 */
function fetchHttp(url, responseType = 'json') {
    return new Promise((/**
     * @param {?} resolve
     * @param {?} reject
     * @return {?}
     */
    (resolve, reject) => {
        /** @type {?} */
        const xhr = new XMLHttpRequest();
        xhr.responseType = responseType;
        xhr.addEventListener('load', (/**
         * @param {?} ev
         * @return {?}
         */
        ev => {
            if (xhr.status !== 200) {
                return reject(xhr);
            }
            resolve(xhr.response);
        }));
        xhr.addEventListener('error', (/**
         * @param {...?} err
         * @return {?}
         */
        (...err) => reject(err)));
        xhr.open('get', url, true);
        xhr.send();
    }));
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/isScully.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable: no-string-literal
/** @type {?} */
const isScullyRunning = (/**
 * @return {?}
 */
() => window && window['ScullyIO'] === 'running');
/** @type {?} */
const isScullyGenerated = (/**
 * @return {?}
 */
() => window && window['ScullyIO'] === 'generated');

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/merge-paths.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} base
 * @param {?} path
 * @return {?}
 */
function mergePaths(base, path) {
    if (base.endsWith('/') && path.startsWith('/')) {
        return `${base}${path.substr(1)}`;
    }
    if (!base.endsWith('/') && !path.startsWith('/')) {
        return `${base}/${path}`;
    }
    return `${base}${path}`;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/transfer-state/transfer-state.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const SCULLY_SCRIPT_ID = `ScullyIO-transfer-state`;
/** @type {?} */
const SCULLY_STATE_START = `/** ___SCULLY_STATE_START___ */`;
/** @type {?} */
const SCULLY_STATE_END = `/** ___SCULLY_STATE_END___ */`;
/** @type {?} */
const initialStateDone = '__done__with__Initial__navigation__';
/**
 * @record
 */
function State() { }
// Adding this dynamic comment to suppress ngc error around Document as a DI token.
// https://github.com/angular/angular/issues/20351#issuecomment-344009887
/**
 * \@dynamic
 */
class TransferStateService {
    /**
     * @param {?} document
     * @param {?} router
     */
    constructor(document, router) {
        this.document = document;
        this.router = router;
        /**
         * parse from index, or load from data.json, according to scullConfig setting
         */
        this.inlineOnly = false;
        /**
         * set the currentBase to something that it can never be
         */
        this.currentBaseUrl = '//';
        /**
         * subject to fire off incoming states
         */
        this.stateBS = new BehaviorSubject({});
        this.state$ = this.stateBS.pipe(filter((/**
         * @param {?} state
         * @return {?}
         */
        (state) => state !== undefined)));
        // emit the next url when routing is complete
        this.nextUrl = this.router.events.pipe(filter((/**
         * @param {?} e
         * @return {?}
         */
        (e) => e instanceof NavigationStart)), switchMap((/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            if (basePathOnly(this.initialUrl) === basePathOnly(e.url)) {
                /** don't kick off on initial load to prevent flicker */
                this.initialUrl = initialStateDone;
                return NEVER;
            }
            return of(e);
        })), 
        /** reset the state, so new components will never get stale data */
        tap((/**
         * @return {?}
         */
        () => this.stateBS.next(undefined))), 
        /** prevent emitting before navigation to _this_ URL is done. */
        switchMap((/**
         * @param {?} e
         * @return {?}
         */
        (e) => this.router.events.pipe(filter((/**
         * @param {?} ev
         * @return {?}
         */
        (ev) => ev instanceof NavigationEnd && ev.url === e.url)), first()))), map((/**
         * @param {?} ev
         * @return {?}
         */
        (ev) => basePathOnly(ev.urlAfterRedirects || ev.url))), shareReplay(1));
    }
    /**
     * @return {?}
     */
    startMonitoring() {
        if (window && window['ScullyIO-injected'] && window['ScullyIO-injected'].inlineStateOnly) {
            this.inlineOnly = true;
        }
        this.setupEnvForTransferState();
        this.setupStartNavMonitoring();
    }
    /**
     * @private
     * @return {?}
     */
    setupEnvForTransferState() {
        if (isScullyRunning()) {
            this.injectScript();
            // In Scully puppeteer
            /** @type {?} */
            const exposed = window['ScullyIO-exposed'] || {};
            if (exposed.transferState) {
                this.stateBS.next(exposed.transferState);
                this.saveState(exposed.transferState);
            }
        }
        else if (isScullyGenerated()) {
            // On the client AFTER scully rendered it
            this.initialUrl = window.location.pathname || '__no_NO_no__';
            this.initialUrl = this.initialUrl !== '/' && this.initialUrl.endsWith('/') ? this.initialUrl.slice(0, -1) : this.initialUrl;
            /** set the initial state */
            this.stateBS.next((window && window[SCULLY_SCRIPT_ID]) || {});
        }
    }
    /**
     * @private
     * @return {?}
     */
    injectScript() {
        this.script = this.document.createElement('script');
        this.script.setAttribute('id', SCULLY_SCRIPT_ID);
        /** @type {?} */
        let last = document.body.lastChild;
        while (last.previousSibling.nodeName === 'SCRIPT') {
            last = (/** @type {?} */ (last.previousSibling));
        }
        document.body.insertBefore(this.script, last);
    }
    /**
     * Getstate will return an observable that containes the data.
     * It does so right after the navigation for the page has finished.
     * please note, this works SYNC on initial route, preventing a flash of content.
     * @template T
     * @param {?} name The name of the state to
     * @return {?}
     */
    getState(name) {
        /** start of the fetch for the current active route. */
        this.fetchTransferState();
        return this.state$.pipe(pluck(name)
        // tap((data) => console.log('tss', data))
        );
    }
    /**
     * Read the current state, and see if it has an value for the name.
     * (note the value it containes still can be undefined!)
     * @param {?} name
     * @return {?}
     */
    stateHasKey(name) {
        return this.stateBS.value && this.stateBS.value.hasOwnProperty(name);
    }
    /**
     * Read the current state, and see if it has an value for the name.
     * ys also if there is actually an value in the state.
     * @param {?} name
     * @return {?}
     */
    stateKeyHasValue(name) {
        return this.stateBS.value && this.stateBS.value.hasOwnProperty(name) && this.stateBS.value[name] != null;
    }
    /**
     * SetState will update the script in the generated page with data added.
     * @template T
     * @param {?} name
     * @param {?} val
     * @return {?}
     */
    setState(name, val) {
        /** @type {?} */
        const newState = Object.assign(Object.assign({}, this.stateBS.value), { [name]: val });
        this.stateBS.next(newState);
        this.saveState(newState);
    }
    /**
     * @private
     * @param {?} newState
     * @return {?}
     */
    saveState(newState) {
        if (isScullyRunning()) {
            this.script.textContent = `{window['${SCULLY_SCRIPT_ID}']=_u(\`${SCULLY_STATE_START}${escapeHtml(JSON.stringify(newState))}${SCULLY_STATE_END}\`);function _u(t){t=t.split('${SCULLY_STATE_START}')[1].split('${SCULLY_STATE_END}')[0];const u={'_~b~': "${'`'}",'_~q~': "'",'_~o~': '$','_~s~': '/','_~l~': '<','_~g~': '>'};return JSON.parse(t.replace(/_~d~/g,'\\\\"').replace(/_~[^]~/g, (s) => u[s]).replace(/\\n/g,'\\\\n').replace(/\\t/g,'\\\\t').replace(/\\r/g,'\\\\r'));}}`;
        }
    }
    /**
     * starts monitoring the router, and keep the url from the last completed navigation handy.
     * @private
     * @return {?}
     */
    setupStartNavMonitoring() {
        if (!isScullyGenerated()) {
            return;
        }
        /** start monitoring the routes */
        this.nextUrl.subscribe();
    }
    /**
     * Wraps an observable into scully's transfer state. If data for the provided `name` is
     * available in the state, it gets returned. Otherwise, the `originalState` observable will
     * be returned.
     *
     * On subsequent calls, the data in the state will always be returned. The `originalState` will
     * be returned only once.
     *
     * This is a convenience method which does not require you to use `getState`/`setState` manually.
     *
     * @template T
     * @param {?} name state key
     * @param {?} originalState an observable which yields the desired data
     * @return {?}
     */
    useScullyTransferState(name, originalState) {
        if (isScullyGenerated()) {
            return this.getState(name);
        }
        return originalState.pipe(tap((/**
         * @param {?} state
         * @return {?}
         */
        (state) => this.setState(name, state))));
    }
    /**
     * @private
     * @return {?}
     */
    fetchTransferState() {
        return __awaiter(this, void 0, void 0, function* () {
            /**
             * helper to read the part before the first slash (ignores leading slash)
             * @type {?}
             */
            const base = (/**
             * @param {?} url
             * @return {?}
             */
            (url) => url.split('/').filter((/**
             * @param {?} part
             * @return {?}
             */
            (part) => part.trim() !== ''))[0]);
            /** put this in the next event cycle so the correct route can be read */
            yield new Promise((/**
             * @param {?} r
             * @return {?}
             */
            (r) => setTimeout(r, 0)));
            /**
             * get the current url
             * @type {?}
             */
            const currentUrl = yield this.nextUrl.pipe(take(1)).toPromise();
            /** @type {?} */
            const baseUrl = base(currentUrl);
            if (this.currentBaseUrl === baseUrl) {
                /** already monitoring, don't tho a thing */
                return;
            }
            /** keep the baseUrl for later reference */
            this.currentBaseUrl = baseUrl;
            this.nextUrl
                .pipe(
            /** keep updating till we move to another route */
            takeWhile((/**
             * @param {?} url
             * @return {?}
             */
            (url) => base(url) === this.currentBaseUrl)), 
            // Get the next route's data from the the index or data file
            switchMap((/**
             * @param {?} url
             * @return {?}
             */
            (url) => (this.inlineOnly ? this.readFromIndex(url) : this.readFromJson(url)))), catchError((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                // TODO: come up with better error text.
                /** the developer needs to know, but its not fatal, so just return an empty state */
                console.warn('Error while loading of parsing Scully state:', e);
                return of({});
            })), tap((/**
             * @param {?} newState
             * @return {?}
             */
            (newState) => {
                /** and activate the state in the components. on any error it will be empty */
                this.stateBS.next(newState);
            })))
                .subscribe({
                /**
                 * when completes (different URL)
                 */
                complete: (/**
                 * @return {?}
                 */
                () => {
                    /** reset the currentBaseUrl */
                    this.currentBaseUrl = '//';
                }),
            });
        });
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    readFromJson(url) {
        return fetchHttp(dropPreSlash(mergePaths(url, '/data.json')));
    }
    /**
     * @private
     * @param {?} url
     * @return {?}
     */
    readFromIndex(url) {
        return fetchHttp(dropPreSlash(mergePaths(url, '/index.html')), 'text').then((/**
         * @param {?} html
         * @return {?}
         */
        (html) => {
            /** @type {?} */
            const newStateStr = html.split(SCULLY_STATE_START)[1].split(SCULLY_STATE_END)[0];
            return JSON.parse(unescapeHtml(newStateStr));
        }));
    }
}
TransferStateService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
TransferStateService.ctorParameters = () => [
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Router }
];
/** @nocollapse */ TransferStateService.ɵprov = ɵɵdefineInjectable({ factory: function TransferStateService_Factory() { return new TransferStateService(ɵɵinject(DOCUMENT), ɵɵinject(Router)); }, token: TransferStateService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    TransferStateService.prototype.script;
    /**
     * parse from index, or load from data.json, according to scullConfig setting
     * @type {?}
     * @private
     */
    TransferStateService.prototype.inlineOnly;
    /**
     * @type {?}
     * @private
     */
    TransferStateService.prototype.initialUrl;
    /**
     * set the currentBase to something that it can never be
     * @type {?}
     * @private
     */
    TransferStateService.prototype.currentBaseUrl;
    /**
     * subject to fire off incoming states
     * @type {?}
     * @private
     */
    TransferStateService.prototype.stateBS;
    /**
     * @type {?}
     * @private
     */
    TransferStateService.prototype.state$;
    /**
     * @type {?}
     * @private
     */
    TransferStateService.prototype.nextUrl;
    /**
     * @type {?}
     * @private
     */
    TransferStateService.prototype.document;
    /**
     * @type {?}
     * @private
     */
    TransferStateService.prototype.router;
}
/**
 * @param {?} string
 * @return {?}
 */
function dropPreSlash(string) {
    return string.startsWith('/') ? string.slice(1) : string;
}
/**
 * we need to escape our HTML to prevent XXS,
 * It needs to be custom, because the content can already contain html-escaped sequences
 *
 * @param {?} text
 * @return {?}
 */
function escapeHtml(text) {
    /** @type {?} */
    const escapedText = {
        "'": '_~q~',
        $: '_~o~',
        '`': '_~b~',
        '/': '_~s~',
        '<': '_~l~',
        '>': '_~g~',
    };
    return (text
        /** escape the json */
        .replace(/[\$`'<>\/]/g, (/**
     * @param {?} s
     * @return {?}
     */
    (s) => escapedText[s]))
        /** replace escaped double-quotes with single */
        .replace(/\\\"/g, `_~d~`));
}
/**
 * Unescape our custom escaped texts
 * @param {?} text
 * @return {?}
 */
function unescapeHtml(text) {
    /** @type {?} */
    const unescapedText = {
        '_~q~': "'",
        '_~b~': '`',
        '_~o~': '$',
        '_~s~': '/',
        '_~l~': '<',
        '_~g~': '>',
    };
    return (text
        /** put back escaped double quotes to make valid json again */
        .replace(/_~d~/g, `\\"`)
        /** replace the custom escapes */
        .replace(/_~[^]~/g, (/**
     * @param {?} s
     * @return {?}
     */
    (s) => unescapedText[s]))
        /** restore newlines+cr */
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r'));
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/idleMonitor/idle-monitor.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function LocalState() { }
if (false) {
    /** @type {?} */
    LocalState.prototype.idle;
    /** @type {?} */
    LocalState.prototype.timeOut;
}
// if (window) {
//   window.addEventListener('AngularReady', ev => {
//     console.log('appReady fired', ev);
//   });
// }
class IdleMonitorService {
    /**
     * @param {?} zone
     * @param {?} router
     * @param {?} conf
     * @param {?} tss
     */
    constructor(zone, router, conf, tss) {
        this.zone = zone;
        this.router = router;
        /**
         * store the 'landing' url so we can skip it in idle-check.
         */
        this.initialUrl = dropEndingSlash(window && window.location && window.location.pathname) || '';
        this.imState = new BehaviorSubject({
            idle: false,
            timeOut: 5 * 1000,
        });
        this.idle$ = this.imState.pipe(pluck('idle'));
        this.initApp = new Event('AngularInitialized', {
            bubbles: true,
            cancelable: false,
        });
        this.appReady = new Event('AngularReady', {
            bubbles: true,
            cancelable: false,
        });
        this.appTimeout = new Event('AngularTimeout', {
            bubbles: true,
            cancelable: false,
        });
        /** provide the default for missing conf paramter */
        this.scullyLibConfig = Object.assign({}, ScullyDefaultSettings, conf);
        /** @type {?} */
        const exposed = window['ScullyIO-exposed'] || {};
        /** @type {?} */
        const manualIdle = !!exposed.manualIdle;
        if (!this.scullyLibConfig.manualIdle && window && (this.scullyLibConfig.alwaysMonitor || isScullyRunning())) {
            window.dispatchEvent(this.initApp);
            this.router.events
                .pipe(filter((/**
             * @param {?} ev
             * @return {?}
             */
            (ev) => ev instanceof NavigationEnd && ev.urlAfterRedirects !== undefined)), 
            /** don't check the page that has this setting. event is only importand on page load */
            filter((/**
             * @param {?} ev
             * @return {?}
             */
            (ev) => (manualIdle ? ev.urlAfterRedirects !== this.initialUrl : true))), tap((/**
             * @return {?}
             */
            () => this.zoneIdleCheck())))
                .subscribe();
        }
        if (this.scullyLibConfig.manualIdle) {
            /** we still need the init event. */
            window.dispatchEvent(this.initApp);
        }
        if (this.scullyLibConfig.useTransferState) {
            /** don't start monitoring if people don't use the transferState */
            tss.startMonitoring();
        }
    }
    /**
     * @return {?}
     */
    fireManualMyAppReadyEvent() {
        return __awaiter(this, void 0, void 0, function* () {
            return window.dispatchEvent(this.appReady);
        });
    }
    /**
     * @return {?}
     */
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.idle$.pipe(take(1)).toPromise();
        });
    }
    /**
     * @private
     * @return {?}
     */
    zoneIdleCheck() {
        return __awaiter(this, void 0, void 0, function* () {
            if (Zone === undefined) {
                return this.simpleTimeout();
            }
            /** @type {?} */
            const taskTrackingZone = Zone.current.get('TaskTrackingZone');
            if (taskTrackingZone === undefined) {
                return this.simpleTimeout();
            }
            if (this.imState.value.idle) {
                yield this.setState('idle', false);
            }
            /** run the actual check for 'idle' outsides zone, otherwise it will never come to an end. */
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                /** @type {?} */
                let tCancel;
                /** @type {?} */
                let count = 0;
                /** @type {?} */
                const startTime = Date.now();
                /** @type {?} */
                const monitor = (/**
                 * @return {?}
                 */
                () => {
                    clearTimeout(tCancel);
                    // console.table(taskTrackingZone.macroTasks);
                    if (Date.now() - startTime > 30 * 1000) {
                        /** bail out after 30 seconds. */
                        window.dispatchEvent(this.appTimeout);
                        return;
                    }
                    if ((taskTrackingZone.macroTasks.length > 0 &&
                        taskTrackingZone.macroTasks.find((/**
                         * @param {?} z
                         * @return {?}
                         */
                        (z) => z.source.includes('XMLHttpRequest'))) !==
                            undefined) ||
                        count < 1 // make sure it runs at least once!
                    ) {
                        tCancel = setTimeout((/**
                         * @return {?}
                         */
                        () => {
                            count += 1;
                            monitor();
                        }), 50);
                        return;
                    }
                    this.zone.run((/**
                     * @return {?}
                     */
                    () => {
                        /** run this inside the zone, and give the app 250Ms to wrap up, before scraping starts */
                        setTimeout((/**
                         * @return {?}
                         */
                        () => {
                            window.dispatchEvent(this.appReady);
                            this.setState('idle', true);
                        }), 250);
                    }));
                });
                monitor();
            }));
        });
    }
    /**
     * @private
     * @return {?}
     */
    simpleTimeout() {
        return __awaiter(this, void 0, void 0, function* () {
            /** zone not available, use a timeout instead. */
            console.warn('Scully is using timeouts, add the needed polyfills instead!');
            yield new Promise((/**
             * @param {?} r
             * @return {?}
             */
            (r) => setTimeout(r, this.imState.value.timeOut)));
            window.dispatchEvent(this.appReady);
        });
    }
    /**
     * @param {?} milliseconds
     * @return {?}
     */
    setPupeteerTimeoutValue(milliseconds) {
        this.imState.next(Object.assign(Object.assign({}, this.imState.value), { timeOut: milliseconds }));
    }
    /**
     * @private
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    setState(key, value) {
        this.imState.next(Object.assign(Object.assign({}, this.imState.value), { [key]: value }));
    }
}
IdleMonitorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
IdleMonitorService.ctorParameters = () => [
    { type: NgZone },
    { type: Router },
    { type: undefined, decorators: [{ type: Inject, args: [SCULLY_LIB_CONFIG,] }] },
    { type: TransferStateService }
];
/** @nocollapse */ IdleMonitorService.ɵprov = ɵɵdefineInjectable({ factory: function IdleMonitorService_Factory() { return new IdleMonitorService(ɵɵinject(NgZone), ɵɵinject(Router), ɵɵinject(SCULLY_LIB_CONFIG), ɵɵinject(TransferStateService)); }, token: IdleMonitorService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    IdleMonitorService.prototype.scullyLibConfig;
    /**
     * store the 'landing' url so we can skip it in idle-check.
     * @type {?}
     * @private
     */
    IdleMonitorService.prototype.initialUrl;
    /**
     * @type {?}
     * @private
     */
    IdleMonitorService.prototype.imState;
    /** @type {?} */
    IdleMonitorService.prototype.idle$;
    /**
     * @type {?}
     * @private
     */
    IdleMonitorService.prototype.initApp;
    /**
     * @type {?}
     * @private
     */
    IdleMonitorService.prototype.appReady;
    /**
     * @type {?}
     * @private
     */
    IdleMonitorService.prototype.appTimeout;
    /**
     * @type {?}
     * @private
     */
    IdleMonitorService.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    IdleMonitorService.prototype.router;
}
/**
 * @param {?} str
 * @return {?}
 */
function dropEndingSlash(str) {
    return str.endsWith('/') ? str.slice(0, -1) : str;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/route-service/scully-routes.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ScullyRoute() { }
if (false) {
    /** @type {?} */
    ScullyRoute.prototype.route;
    /** @type {?|undefined} */
    ScullyRoute.prototype.title;
    /** @type {?|undefined} */
    ScullyRoute.prototype.slugs;
    /** @type {?|undefined} */
    ScullyRoute.prototype.published;
    /** @type {?|undefined} */
    ScullyRoute.prototype.slug;
    /** @type {?|undefined} */
    ScullyRoute.prototype.sourceFile;
    /** @type {?|undefined} */
    ScullyRoute.prototype.lang;
    /* Skipping unhandled member: [prop: string]: any;*/
}
class ScullyRoutesService {
    /**
     * @param {?} router
     */
    constructor(router) {
        this.router = router;
        this.refresh = new ReplaySubject(1);
        /**
         * An observable with all routes, published and unpublished alike
         */
        this.allRoutes$ = this.refresh.pipe(switchMap((/**
         * @return {?}
         */
        () => fetchHttp('assets/scully-routes.json'))), catchError((/**
         * @return {?}
         */
        () => {
            console.warn('Scully routes file not found, are you running the Scully generated version of your site?');
            return of((/** @type {?} */ ([])));
        })), 
        /** filter out all non-array results */
        filter((/**
         * @param {?} routes
         * @return {?}
         */
        (routes) => Array.isArray(routes))), map(this.cleanDups), shareReplay({ refCount: false, bufferSize: 1 }));
        /**
         * An observable with available routes (all published routes)
         */
        this.available$ = this.allRoutes$.pipe(map((/**
         * @param {?} list
         * @return {?}
         */
        (list) => list.filter((/**
         * @param {?} r
         * @return {?}
         */
        (r) => r.hasOwnProperty('published') ? r.published !== false : true)))), shareReplay({ refCount: false, bufferSize: 1 }));
        /**
         * an observable with all unpublished routes
         */
        this.unPublished$ = this.allRoutes$.pipe(map((/**
         * @param {?} list
         * @return {?}
         */
        (list) => list.filter((/**
         * @param {?} r
         * @return {?}
         */
        (r) => r.hasOwnProperty('published') ? r.published === false : false)))), shareReplay({ refCount: false, bufferSize: 1 }));
        /**
         * An observable with the top-level off all published routes.
         * (in an urls it would be `http://www.sample.org/__thisPart__/subroutes`)
         */
        this.topLevel$ = this.available$.pipe(map((/**
         * @param {?} routes
         * @return {?}
         */
        (routes) => routes.filter((/**
         * @param {?} r
         * @return {?}
         */
        (r) => !r.route.slice(1).includes('/'))))), shareReplay({ refCount: false, bufferSize: 1 }));
        /** kick off first cycle */
        this.reload();
    }
    /**
     * returns an observable that returns the route information for the
     * route currently selected. subscribes to route-events to update when needed
     * @return {?}
     */
    getCurrent() {
        if (!location) {
            /** probably not in a browser, no current location available */
            return of();
        }
        /** fire off at start, and when navigation is done. */
        return merge(of(new NavigationEnd(0, '', '')), this.router.events).pipe(filter((/**
         * @param {?} e
         * @return {?}
         */
        (e) => e instanceof NavigationEnd)), switchMap((/**
         * @return {?}
         */
        () => this.available$)), map((/**
         * @param {?} list
         * @return {?}
         */
        (list) => {
            /** @type {?} */
            const curLocation = basePathOnly(encodeURI(location.pathname).trim());
            return list.find((/**
             * @param {?} r
             * @return {?}
             */
            (r) => curLocation === basePathOnly(r.route.trim()) ||
                (r.slugs &&
                    Array.isArray(r.slugs) &&
                    r.slugs.find((/**
                     * @param {?} slug
                     * @return {?}
                     */
                    (slug) => curLocation.endsWith(basePathOnly(slug.trim())))))));
        })));
    }
    /**
     * internal, as routes can have multiple slugs, and so occur multiple times
     * this util function collapses all slugs back into 1 route.
     * @private
     * @param {?} routes
     * @return {?}
     */
    cleanDups(routes) {
        /** @type {?} */
        const m = new Map();
        /** check for duplicates by comparing all, include route in comparison if its the only thing, or the only thing with only the tile  */
        routes.forEach((/**
         * @param {?} r
         * @return {?}
         */
        (r) => m.set(JSON.stringify(Object.assign(Object.assign({}, r), { route: hasOtherprops(r) ? '' : r.route })), r)));
        return [...m.values()];
    }
    /**
     * an utility that will force a reload of the `scully-routes.json` file
     * @return {?}
     */
    reload() {
        this.refresh.next();
    }
}
ScullyRoutesService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
ScullyRoutesService.ctorParameters = () => [
    { type: Router }
];
/** @nocollapse */ ScullyRoutesService.ɵprov = ɵɵdefineInjectable({ factory: function ScullyRoutesService_Factory() { return new ScullyRoutesService(ɵɵinject(Router)); }, token: ScullyRoutesService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    ScullyRoutesService.prototype.refresh;
    /**
     * An observable with all routes, published and unpublished alike
     * @type {?}
     */
    ScullyRoutesService.prototype.allRoutes$;
    /**
     * An observable with available routes (all published routes)
     * @type {?}
     */
    ScullyRoutesService.prototype.available$;
    /**
     * an observable with all unpublished routes
     * @type {?}
     */
    ScullyRoutesService.prototype.unPublished$;
    /**
     * An observable with the top-level off all published routes.
     * (in an urls it would be `http://www.sample.org/__thisPart__/subroutes`)
     * @type {?}
     */
    ScullyRoutesService.prototype.topLevel$;
    /**
     * @type {?}
     * @private
     */
    ScullyRoutesService.prototype.router;
}
/**
 * @param {?} obj
 * @return {?}
 */
function hasOtherprops(obj) {
    /** @type {?} */
    const keys = Object.keys(obj);
    if (keys.length === 1 && keys.includes('route')) {
        return false;
    }
    if (keys.length === 2 && keys.includes('route') && keys.includes('title')) {
        return false;
    }
    return true;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/findComments.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Returns an array of nodes coninting all the html comments in the element.
 * When a searchText is given this is narrowed down to only comments that contian this text
 * @param {?} rootElem Element to search nto
 * @param {?=} searchText optional string that needs to be in a HTML comment
 * @return {?}
 */
function findComments(rootElem, searchText) {
    /** @type {?} */
    const comments = [];
    // Fourth argument, which is actually obsolete according to the DOM4 standard, seems required in IE 11
    /** @type {?} */
    const iterator = document.createNodeIterator(rootElem, NodeFilter.SHOW_COMMENT, {
        acceptNode: (/**
         * @param {?} node
         * @return {?}
         */
        node => {
            // Logic to determine whether to accept, reject or skip node
            // In this case, only accept nodes that have content
            // that is containing our searchText, by rejecting any other nodes.
            if (searchText &&
                node.nodeValue &&
                !node.nodeValue.includes(searchText)) {
                return NodeFilter.FILTER_REJECT;
            }
            return NodeFilter.FILTER_ACCEPT;
        })
    }
    // , false // IE-11 support requires this parameter.
    );
    /** @type {?} */
    let curNode;
    // tslint:disable-next-line: no-conditional-assignment
    while ((curNode = iterator.nextNode())) {
        comments.push(curNode);
    }
    return comments;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/scully-content/scully-content.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ScullyContent() { }
if (false) {
    /** @type {?} */
    ScullyContent.prototype.html;
    /** @type {?} */
    ScullyContent.prototype.cssId;
}
/**
 * this is needed, because otherwise the CLI borks while building
 * @type {?}
 */
const scullyBegin = '<!--scullyContent-begin-->';
/** @type {?} */
const scullyEnd = '<!--scullyContent-end-->';
/**
 * use the module's closure to keep a system-wide check for the last handled URL.
 * @type {?}
 */
let lastHandled;
class ScullyContentComponent {
    /**
     * @param {?} elmRef
     * @param {?} srs
     * @param {?} router
     * @param {?} location
     * @param {?} conf
     */
    constructor(elmRef, srs, router, location, conf) {
        this.elmRef = elmRef;
        this.srs = srs;
        this.router = router;
        this.location = location;
        this.conf = conf;
        this.baseUrl = this.conf.useTransferState || ScullyDefaultSettings.useTransferState;
        this.elm = (/** @type {?} */ (this.elmRef.nativeElement));
        /**
         * pull in all  available routes into an eager promise
         */
        this.routes = this.srs.allRoutes$.pipe(take(1)).toPromise();
        /**
         * monitor the router, so we can update while navigating in the same 'page' see #311
         */
        this.routeUpdates$ = this.router.events.pipe(filter((/**
         * @param {?} ev
         * @return {?}
         */
        (ev) => ev instanceof NavigationEnd)), 
        /** don't replace if we are already there */
        filter((/**
         * @param {?} ev
         * @return {?}
         */
        (ev) => lastHandled && !lastHandled.endsWith(ev.urlAfterRedirects))), tap((/**
         * @param {?} r
         * @return {?}
         */
        (r) => this.replaceContent())));
        this.routeSub = this.routeUpdates$.subscribe();
        /** do this from constructor, so it runs ASAP */
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.elm) {
            /** this will only fire in a browser environment */
            this.handlePage();
        }
    }
    /**
     * Loads the static content from scully into the view
     * Will fetch the content from sibling links with xmlHTTPrequest
     * @private
     * @return {?}
     */
    handlePage() {
        return __awaiter(this, void 0, void 0, function* () {
            /** @type {?} */
            const curPage = basePathOnly(location.href);
            if (lastHandled === curPage) {
                /**
                 * Due to the fix we needed for #311
                 * it might happen that this routine is called
                 * twice for the same page.
                 * this code will make sure the second one is ignored.
                 */
                return;
            }
            lastHandled = curPage;
            /** @type {?} */
            const template = document.createElement('template');
            /** @type {?} */
            const currentCssId = this.getCSSId(this.elm);
            if (window.scullyContent) {
                /**
                 * upgrade existing static content
                 * @type {?}
                 */
                const htmlString = window.scullyContent.html;
                if (currentCssId !== window.scullyContent.cssId) {
                    /** replace the angular cssId */
                    template.innerHTML = htmlString.split(window.scullyContent.cssId).join(currentCssId);
                }
                else {
                    template.innerHTML = htmlString;
                }
            }
            else {
                /**
                 *   NOTE
                 * when updateting the texts for the errors, make sure you leave the
                 *  `id="___scully-parsing-error___"`
                 * in there. That way users can detect rendering errors in their CI
                 * on a reliable way.
                 */
                yield fetchHttp(curPage + '/index.html', 'text')
                    .catch((/**
                 * @param {?} e
                 * @return {?}
                 */
                (e) => {
                    if (isDevMode()) {
                        /**
                         * in devmode (usually in `ng serve`) check the scully server for the content too
                         * @type {?}
                         */
                        const uri = new URL(location.href);
                        /** @type {?} */
                        const url = `${this.conf.baseURIForScullyContent}/${basePathOnly(uri.pathname)}/index.html`;
                        return fetchHttp(url, 'text');
                    }
                    else {
                        return Promise.reject(e);
                    }
                }))
                    .then((/**
                 * @param {?} html
                 * @return {?}
                 */
                (html) => {
                    try {
                        /** @type {?} */
                        const htmlString = html.split(scullyBegin)[1].split(scullyEnd)[0];
                        if (htmlString.includes('_ngcontent')) {
                            /**
                             * update the angular cssId
                             * @type {?}
                             */
                            const atr = '_ngcontent' + htmlString.split('_ngcontent')[1].split('=')[0];
                            template.innerHTML = htmlString.split(atr).join(currentCssId);
                        }
                        else {
                            template.innerHTML = htmlString;
                        }
                    }
                    catch (e) {
                        template.innerHTML = `<h2 id="___scully-parsing-error___">Sorry, could not parse static page content</h2>
            <p>This might happen if you are not using the static generated pages.</p>`;
                    }
                }))
                    .catch((/**
                 * @param {?} e
                 * @return {?}
                 */
                (e) => {
                    template.innerHTML = '<h2 id="___scully-parsing-error___">Sorry, could not load static page content</h2>';
                    console.error('problem during loading static scully content', e);
                }));
            }
            /**
             * insert the whole thing just before the `<scully-content>` element
             * @type {?}
             */
            const parent = this.elm.parentElement || document.body;
            /** @type {?} */
            const begin = document.createComment('scullyContent-begin');
            /** @type {?} */
            const end = document.createComment('scullyContent-end');
            parent.insertBefore(begin, this.elm);
            parent.insertBefore(template.content, this.elm);
            parent.insertBefore(end, this.elm);
            /** upgrade all hrefs to simulated routelinks (in next microtask) */
            setTimeout((/**
             * @return {?}
             */
            () => document.querySelectorAll('[href]').forEach(this.upgradeToRoutelink.bind(this))), 10);
            // document.querySelectorAll('[href]').forEach(this.upgradeToRoutelink.bind(this));
        });
    }
    /**
     * upgrade a **href** attributes to links that respect the Angular router
     * and don't do a full page reload. Only works on links that are found in the
     * Scully route config file.
     * @param {?} elm the element containing the **hrefs**
     * @return {?}
     */
    upgradeToRoutelink(elm) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!['A', 'BUTTON'].includes(elm.tagName)) {
                return;
            }
            /** @type {?} */
            const hash = elm.dataset.hash;
            if (hash) {
                elm.setAttribute('href', '#' + hash);
                elm.setAttribute('onclick', '');
                elm.onclick = (/**
                 * @param {?} ev
                 * @return {?}
                 */
                (ev) => {
                    ev.preventDefault();
                    /** @type {?} */
                    const destination = document.getElementById(hash);
                    if (destination) {
                        /** @type {?} */
                        const url = new URL(window.location.href);
                        url.hash = hash;
                        history.replaceState('', '', url.toString());
                        destination.scrollIntoView();
                    }
                });
                return;
            }
            /** @type {?} */
            const routes = yield this.routes;
            /** @type {?} */
            const href = elm.getAttribute('href');
            /** @type {?} */
            const lnk = basePathOnly(href.toLowerCase());
            /** @type {?} */
            const route = routes.find((/**
             * @param {?} r
             * @return {?}
             */
            (r) => basePathOnly(r.route.toLowerCase()) === lnk));
            /** only upgrade routes known by scully. */
            if (lnk && route && !lnk.startsWith('#')) {
                elm.onclick = (/**
                 * @param {?} ev
                 * @return {?}
                 */
                (ev) => __awaiter(this, void 0, void 0, function* () {
                    /** @type {?} */
                    const splitRoute = route.route.split(`/`);
                    /** @type {?} */
                    const curSplit = location.pathname.split('/');
                    // loose last "part" of route
                    curSplit.pop();
                    ev.preventDefault();
                    /** @type {?} */
                    const routed = yield this.router.navigate(splitRoute).catch((/**
                     * @param {?} e
                     * @return {?}
                     */
                    (e) => {
                        console.error('routing error', e);
                        return false;
                    }));
                    if (!routed) {
                        return;
                    }
                    /** check for the same route with different "data", and NOT a 1 level higher (length), and is not a fragment of th same page */
                    if (curSplit.every((/**
                     * @param {?} part
                     * @param {?} i
                     * @return {?}
                     */
                    (part, i) => splitRoute[i] === part)) && splitRoute.length !== curSplit.length + 1) {
                        setTimeout((/**
                         * @return {?}
                         */
                        () => this.replaceContent()), 10); // a small delay, so we are sure the angular parts in the page are settled enough
                    }
                }));
            }
        });
    }
    /**
     * @private
     * @return {?}
     */
    replaceContent() {
        /**
         * as Angular doesn't destroy the component if we stay on the same page,
         * we have to manually delete old content. Also we need to kick of loading
         * the new content. handlePage() takes care of that.
         */
        /** delete the content, as it is now out of date! */
        window.scullyContent = undefined;
        /** @type {?} */
        const parent = this.elm.parentElement;
        /** @type {?} */
        let cur = (/** @type {?} */ (findComments(parent, 'scullyContent-begin')[0]));
        while (cur && cur !== this.elm) {
            /** @type {?} */
            const next = cur.nextSibling;
            parent.removeChild(cur);
            cur = next;
        }
        this.handlePage();
    }
    /**
     * @param {?} elm
     * @return {?}
     */
    getCSSId(elm) {
        return elm.getAttributeNames().find((/**
         * @param {?} a
         * @return {?}
         */
        (a) => a.startsWith('_ngcontent'))) || '';
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.routeSub.unsubscribe();
        /** reset the lastused */
        lastHandled = '//';
    }
}
ScullyContentComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line: component-selector
                selector: 'scully-content',
                template: '<ng-content></ng-content>',
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                preserveWhitespaces: true,
                styles: [`
      :host {
        display: none;
      }
      scully-content {
        display: none;
      }
    `]
            }] }
];
/** @nocollapse */
ScullyContentComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ScullyRoutesService },
    { type: Router },
    { type: Location },
    { type: undefined, decorators: [{ type: Inject, args: [SCULLY_LIB_CONFIG,] }] }
];
if (false) {
    /** @type {?} */
    ScullyContentComponent.prototype.baseUrl;
    /** @type {?} */
    ScullyContentComponent.prototype.elm;
    /**
     * pull in all  available routes into an eager promise
     * @type {?}
     */
    ScullyContentComponent.prototype.routes;
    /**
     * monitor the router, so we can update while navigating in the same 'page' see #311
     * @type {?}
     */
    ScullyContentComponent.prototype.routeUpdates$;
    /** @type {?} */
    ScullyContentComponent.prototype.routeSub;
    /**
     * @type {?}
     * @private
     */
    ScullyContentComponent.prototype.elmRef;
    /**
     * @type {?}
     * @private
     */
    ScullyContentComponent.prototype.srs;
    /**
     * @type {?}
     * @private
     */
    ScullyContentComponent.prototype.router;
    /**
     * @type {?}
     * @private
     */
    ScullyContentComponent.prototype.location;
    /**
     * @type {?}
     * @private
     */
    ScullyContentComponent.prototype.conf;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/scully-content/scully-content.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ScullyContentModule {
}
ScullyContentModule.decorators = [
    { type: NgModule, args: [{
                declarations: [ScullyContentComponent],
                exports: [ScullyContentComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/scully-lib.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ScullyLibModule {
    /**
     * @param {?} idle
     */
    constructor(idle) {
        this.idle = idle;
    }
    /**
     * We use a little trick to get a working idle-service.
     * First, we separate out the component in a separate module to prevent a circulair injection
     * second we create a constuctor that activates the IdleMonitorService. as that is provided for 'root'
     * there will be only 1 instance in our app.
     * We don't need forRoot, as we are not configuring anything in here.
     * @param {?=} config
     * @return {?}
     */
    static forRoot(config = ScullyDefaultSettings) {
        config = Object.assign({}, ScullyDefaultSettings, config);
        return {
            ngModule: ScullyLibModule,
            providers: [{ provide: SCULLY_LIB_CONFIG, useValue: config }],
        };
    }
}
ScullyLibModule.decorators = [
    { type: NgModule, args: [{
                imports: [ScullyContentModule],
                exports: [ScullyContentModule],
            },] }
];
/** @nocollapse */
ScullyLibModule.ctorParameters = () => [
    { type: IdleMonitorService }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    ScullyLibModule.prototype.idle;
}

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: scullyio-ng-lib.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { IdleMonitorService, ScullyContentComponent, ScullyContentModule, ScullyLibModule, ScullyRoutesService, TransferStateService, dropEndingSlash, isScullyGenerated, isScullyRunning, SCULLY_LIB_CONFIG as ɵb };
//# sourceMappingURL=scullyio-ng-lib.js.map
